<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Monospace</title>
    <link href="https://devnoff.github.io/feed.xml" rel="self" />
    <link href="https://devnoff.github.io" />
    <updated>2019-06-13T23:24:22+09:00</updated>
    <author>
        <name>devnoff</name>
    </author>
    <id>https://devnoff.github.io</id>

    <entry>
        <title>SPA 자동 배포 (Git + Jenkins + AWS)</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/spa-auto-deployment-git-jenkins-aws.html"/>
        <id>https://devnoff.github.io/spa-auto-deployment-git-jenkins-aws.html</id>

        <updated>2019-06-13T15:08:42+09:00</updated>
            <summary>
                <![CDATA[
                    Git + Jenkins + Docker + S3 + CloudFront 를 이용해 간단한&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Git + Jenkins + Docker + S3 + CloudFront 를 이용해 간단한 React.js 기반 SPA를 자동 배포하는 시스템을 만들어 볼 것이다.</p>
<p>SPA는 static web hosting이 지원되는 어떤 플랫폼에 올려도 동작을 하기 때문에 다양한 배포 환경을 구성할 수 있다. Netlify 와 같이 SPA에 최적화된 CI/CD 및 호스팅을 제공하는 SaaS를 이용하거나, Google Firebase, Amazon S3 + CloudFront(CDN) 등의 static web hosting 이 지원되는 Cloud 기반 서비스를 이용하는 방법이 있는데, 이 글에서는 AWS S3 + CloudFront 방식을 진행 할 것이다.</p>
<p>AWS S3와 CloudFront 를 같이 사용하는 이유는 S3는 static web hosting 을 그리고 CloudFront 는 AWS Certificate Manager를 통해 생성한 SSL/TLS 무료 인증서를 설정해 HTTPS 환경을 구현할 수 있기 때문이다.</p>
<p>전체 과정을 요약 하면 다음과 같다.</p>
<ol>
<li>React 프로젝트 및 git 저장소 생성
<ol>
<li>webpack 빌드 설정</li>
</ol>
</li>
<li>S3 버킷 및 CloudFront 설정</li>
<li>빌드 서버 설정
<ol>
<li>Jenkins 설치</li>
<li>빌드 의존성 설치</li>
<li>Jenkins 설정
<ol>
<li>빌드 스크립트 작성</li>
</ol>
</li>
</ol>
</li>
<li>Github Webhook 과 Jenkins Build Trigger 연결</li>
</ol>
<h2 id="mcetoc_1dd7ln67k0">React 프로젝트 및 git 저장소 생성</h2>
<p>먼저 배포를 할 샘플 SPA 앱을 만든다. <a href="https://www.robinwieruch.de/minimal-react-webpack-babel-setup/">이 곳</a>을 참조하여 만든 boilerplate를 이용해 가장 기본적인 수준의 React.js SPA 개발 환경을 생성한다.</p>
<p>배포 환경을 고려하여 webpack 설정을 바꾼다. webpack 설정은 <a href="https://webpack.js.org/guides/production">공식 문서</a>를 참조하였다. 기존의 webpack.config.js 파일 하나로 이루어진 설정 파일을 환경에 따라서 다음과 같이 나눈다.</p>
<ul>
<li>webpack.common.js</li>
<li>webpack.prod.js</li>
<li>webpack.dev.js</li>
</ul>
<p>공통적으로 적용되는 부분은 webpack.common.js 로 따로 뺐다. 그리고 webpack.prod.js 와 webpack.dev.js 에서 webpack-merge 를 이용해 공통 설정을 불러와 머지를 지시킨다. 중복된 설정이 줄어들어 코드가 간결하다.</p>
<p><strong>clean-webpack-plugin</strong> 과 <strong>html-webpack-plugin</strong> 를 <strong>--save-dev</strong> 플래그로 설치한다</p>
<p>둘의 용도는 다음과 같다.</p>
<ul>
<li><strong>HtmlWebpackPlugin</strong> : webpack 빌드를 통해 생성된 bundle 을 로드할 html 파일을 생성 해준다. 파일명에 해시가 포함되어 빌드 시에 매번 파일명이 바뀌는 경우에 유용하다. 플러그인이 생성한 HTML 파일을 사용하거나, 템플릿 로더로 템플릿을 이용할 수 있다.</li>
<li><strong>CleanWebpackPlugin</strong> : 매 빌드 시 output 디렉토리를 비워준다.</li>
</ul>
<p>디버깅을 위한 <strong>inline-source-map</strong> 을 설치한다.</p>
<p>./dist/index.html 파일을 ./src/assets/index.html 로 이동 시킨 후 webpack.common.js 설정에서 템플릿으로 지정해준다.</p>
<p>package.json 의 scripts 항목에 start 명령을 변경하고, build 명령을 추가한다.</p>
<pre><code>{ 
	"start": "webpack-dev-server --config ./webpack.dev.js",
	"build" : "webpack --config webpack.prod.js"
}
</code></pre>
<p>dist 디렉토리가 빌드에 의해 동적으로 생성 되는 파일을 담는 목적으로 바뀌었기 때문에 .gitignore 에 dist 를 추가하여 형상관리에서 제외를 시킨다.</p>
<p>여기 까지 진행된 상태에서 git 에 저장소를 생성하여 소스를 push 한다. 현재 프로젝트 디렉토리가 boilerplate 의 저장소와 연결되어 있으니 우선 .git 디릭토리를 제거하고 git 초기화를 한 뒤 새로 생성한 저장소를 추가한다.</p>
<pre><code># 저장소 제거
$ rm -rf .git

# git 초기화
$ git init
$ git add .
$ git commit -m 'Initial commit'

# 새로 생성한 저장소 추가
$ git remote add origin git@github.com:devnoff/myProject.git

# 푸시
$ git push origin master
</code></pre>
<p>이렇게 git 저장소에 올려진 소스코드는 Jenkins 빌드 설정에 의해 빌드 서버에서 사용되고, 빌드가 요청 되면 git 으로 부터 내려 받아져 빌드 명령에 의해 dependancy 설치 등의 과정을 거치고 빌드가 진행된다.</p>
<p>위에서 작성된 코드는 다음 주소에서 확인할 수 있다.</p>
<p>Github : <a href="https://github.com/devnoff/myProject">https://github.com/devnoff/myProject</a></p>
<h3 id="mcetoc_1dd7ln67k1">S3 버킷 및 CloudFront 설정</h3>
<p>S3, Cloudfront, ACM, Route53 를 이용해 HTTPS website 호스팅을 하므로써 운영 환경을 구축한다. 방법은 <a href="https://medium.com/@itsmattburgess/hosting-a-https-website-using-aws-s3-and-cloudfront-ee6521df03b9">이 글</a>을 참조</p>
<p>빌드 서버에서 AWS CLI 를 이용해 S3 에 빌드된 파일을 업로드 하고 CloudFront CDN에 재배포하는 과정은 빌드 스크립트 작성 부분에서 설명하겠다.</p>
<h2 id="mcetoc_1dd7ln67k2">빌드 서버 설정</h2>
<h3 id="mcetoc_1dd7ln67k3">Jenkins 설치</h3>
<p>Jenkins 설정 전 까지 다음의 과정이 선행 되어야 한다.</p>
<ol>
<li>EC2 Instance 추가</li>
<li>NginX 설치, SSL 설정</li>
<li>Docker 설치 - <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">설치 방법</a></li>
<li>Dockerized Jenkins 설치 - <a href="https://jybaek.tistory.com/764">설치 방법</a></li>
<li>빌드 의존성 설치 : 배포할 React.js 앱의 빌드에 필요한 node.js 와 webpack 을 Jenkins 컨테이너에 설치</li>
</ol>
<p>결과적으로 필자가 설정한 환경에서 Jenkins 는 맨앞단에 NginX 두고 reverse proxy 설정을 통해 443 포트와 docker 컨테이너의 외부 포트인 8080 을 연결해 주고, docker 컨테이너의 내부 50000 포트를 통해 실행된다.</p>
<p><strong>443</strong> → <strong>nginx</strong> → <strong>8080</strong> → <strong>Docker</strong> → <strong>50000</strong> → <strong>Jenkins</strong></p>
<p>Nginx 와 reverse proxy를 사용하는 이유는 HTTPS 를 활성화 하고 내부망과 외부망에 대한 접근 권한의 달리 구성하여 보안을 강화하기 위함이다. <a href="http://mikehadlow.blogspot.com/2013/05/the-benefits-of-reverse-proxy.html">참조</a></p>
<h3 id="mcetoc_1dd7ln67k4">빌드 의존성 설치</h3>
<p>개발 환경과 버전을 일치하여 SPA 빌드에 필요한 다음의 의존성을 설치한다. (설치 방법은 생략)</p>
<ul>
<li>node.js</li>
<li>webpack</li>
</ul>
<h3 id="mcetoc_1dd7ln67k5">Jenkins 설정</h3>
<p>새 프로젝트 추가를 추가 한다. item name 으로 workspace 디렉토리가 생성 되는 점에 유의 한다.</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a008ae95-862a-4891-80d1-fc2d818d25cd/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45EBM2UBFW%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T054554Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDs0mQgGxudqxSwJx7EgI6nQxZ3QAIfktF%2Fpv6b27nSWgIhAPSg2TtOstKeCqxKWAS2KUf3dYAJQ8EUh3ouqZTPNzB1KuMDCM3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMMjc0NTY3MTQ5MzcwIgwx8h7%2F7Yu%2B%2BJ5kPnIqtwPoPzPlWPxoeW36EP0t2HxWQbBkPEbyqEV89D%2BeuS1C7ltEoKLRBbOaz2cyXUbZ4tln2rOQKOGgDo68TnedvvebMHmfBAzjbbLh%2BvpEp23objnUklxcJsnUA1%2Bh9MIYzRR1Od9umSnqKQeNOUiDbLtycnI02EYmKVpq4yzYXD7faixYDwG974EOxTjEmE%2Bnzjv2yh%2FD%2FMUq%2Fk9d7%2F3i99yqvlCEVRZWth%2BqbD7MDph7ASBlw6nGwOyl7wwSwirSMZhRBNPQcu%2B8Y3ZNkFCg%2B%2BIR0lCdubm884qfUipeyKkE%2BploXIDycTcYtDv5UWKS%2FpaHFHOIgKwv9kr2bXyJAzxAlpYTvoOv5lXzAKK%2BLwO0U3Ves95jhNRRp0fMtk%2BuLNSxyYcy3afGsRfUO47C7xiGR%2FBb%2B%2F7SBc%2BJZDYJej%2BJT0KPfDOtfk3TKs4pkw%2FPbaRESNlVxyVbpsiGUGvGY6NUzOsh9U%2FAAnL%2B3%2FDXr0XswthSG4nDpgPuSufPmwwHE1Jup0cVtRIjNcwBMhsoAph5nny2aF2mpRgerjnWzbrgmcKA3iJ6OComL6eghbXdeFBxpe8tacabMOOah%2BgFOrMB3sHZA1EAK2g1acriXuEJ8ZKxZkAcF8z3NsCWfBBIVKWunNT9lyZIUZEWWWECUmAzCXlPofAfBe0OzGDdXY8LgQz3YbC8uoryXqYTEILlsk7uw9gXas5cbtu9S0NM6%2Fwqm0u1MKIAL0iZeKWNH%2FzZ9IUyJdIVOkux7V%2BzUouYmoKg5llgMx5Fp6Q7xS0F3ZpjwojcerCpci3MqEe39FINeSt5iUFBrSM5pHRlCyKXl%2BkMjog%3D&amp;X-Amz-Signature=0f2bff039a0aeb9b208e12d96e513f62ecee84558ec639678e1d22b97ad403eb&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt=""></p>
<p>OK를 누르면 프로젝트 설정으로 넘어온다. Github webhook 을 통해 payload 를 받으려면 매개 변수 설정이 필요하다. General 탭에서 다음과 같이 String parameter 매개변수를 추가한다</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/000a7933-ca51-46d0-b0b1-f1591bb3a210/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45HNCD6VIC%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T054627Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQC2t29ZbWl7bNHs%2B429m4BC4cv45AlJw6Hwxg1k%2FuhE1wIgUiDRVQKmCXmOpFeYBc1MZe03UEoOASBL%2Bkl6mRlKPygq4wMIzf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDFBnlX1TA6GyZz0V%2Fyq3A1hEHlW87PIHVIkEBOmBrdRrTbgTpXNLDiNk0Hrg3jahXueYnjWdycXB1c0AsiszeNjc5t3iYLTqzhXRRxF6h5d4RQEEVujJ6xvJo8CflTct7vcsbxoslLz6lns4j0XAitQfcFjSiijN3agXGgUP4nLaW0UqIBIevjaI9uzA0TxYOuoLoYbDTb6tWHrC2vPP6ts8A9wNZUE0Og5mDNjewapz9LzK1n8inZqqG3148ViZhIM3WVEC0myZ2EZvG1b%2FoQaB%2B6JcmLhY%2FPHz6USoGCwQEcTNJ1U%2B0oK4j1ve8GGlOgKFTVoYclB00OvFi%2FZXjAgb7Gm62KUek0pLiKDJ1oNkYFcEafuf1rkT3S7JfZUcGkA8kTO9NvQkhry3IOSRkZrAUm7bud%2BFmUw4t04%2FauTVGCvHOU%2FTq%2FZR4Cv3Vq9Q61qxMURcD6lbgdRy1%2FN7pPxTMjE2YyVeWq4pRn2%2FQ1SsIl1srHw4MiOXDkJh5hAQBeEKvd2TDQFGks2VIMw%2BZNa1aqYeeXofQSoOJ29reuvIkCcDRAM%2BtvG6s25lqvMR8lkda7jvnT9fz8Tr7IfUx2avEzZOtO0w2pyH6AU6tAGWG3ttLKqOKj6DJ9kT2%2BasT8oWmUbyfLVP%2B%2FYhLbQDIiVNIJZeGFHOeb2xzFR8L%2FPywC0tvSFZ0qdtcbDGWPULYOUAQCwdWv8fZFA%2FMLXU18qtUsrExIt6B7cfu11a0JzfEf72dLgYwdCEKvK1NkS9iYsRMGJbPVPrP7TecKjPHhfvPj4II3tYSYVoiEHyElY9cair1mSEazQdSKBZJDXCSyvdsCrEe9gwSzW3Xc8wfR3yssM%3D&amp;X-Amz-Signature=3069c8e5b1a7645f7ba1153274ce37bbecea792a7aef627f0e778dbfee7558e0&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="657" height="322"></p>
<p>다음으로 소스 코드 관리 탭으로 이동해서 Git을 선택 후 저장소의 주소를 입력한다.</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7c730cdd-ec39-48ce-936d-dd3e0cddd812/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45F65M66E2%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T054644Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKrML2vI7vVzhM97Bt5EZf1J66ISCk6%2Bxm2aj5GBRV8gIgIcV7DFb1wLRNLywWfV00UfcaIZQgr8D7qQHaK0Lvkdsq4wMIzv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDL%2Fg8jDrJAzOtOFpcyq3Aw9rNyo2DUdhrs%2FV%2Fa8Mll3mHPOunuZ15zWcgqGAUghVZ6nDwAF%2BDJ8S%2Fcu90QqKW9oaR5v2jf6xPnaVis4meD%2FUSdvYcFwSmyqE7TJ%2BynEXf4H5qtlza1p%2BOGG13CPk5TYOoymtIYWTn8u29AIKP3dRWGrxodp6IXVo%2BP6fRq6SskYuSdibnF8b1lHsMLHKOXTp8m5%2B8X5Hd581uRhPPioKH%2B%2FIJ25yxetSEuZrhKc4oCzhP%2FFUzDHgOGUbkGe%2BO9UzPK7orfwwl5FQ%2BM4aX7gPG9ptt1osS%2BXoWKSTvD56JRls0gOQ9W47vSeJZYwl91NgPqOhDf5wVp4b5u6I%2Fevvx3w4nClUoGaHEQJFvOKqpqaauXMmR%2B9c9kKXrN6PPV9NGNE6%2BMEfiA7%2BVskpb9Tn5gtdguTCweSKbn2z5zNUGkACuVcyPmQPO7YkkRgjui1VlE6lhUIPYmwnq1CCg1VBSy3y16vfTd9appXH%2FolX%2FMdPj0ROpxeOZUab9sHWjmtmKTMLBF7UWGIwEag8kg6yB%2FL4iG6H%2B7Q5cttg7nl1cybnTjmt11wqgBLD%2F6JSX8X6zkHpYrwwvKKH6AU6tAG9HlCfX2mGWP6120rAQzF%2BcNOvCNlXcwIK7iLX%2FiD7kF%2F9Q9B2819vKYNU1GmQzSgIDhcBU4%2B2bJOD%2FGs8bxwqKPfjrlbXRqEc8%2BVmKp%2BVYO%2FpASLSvt2eg0clPLgkKzrim7vWJQURM6NSdlLVcPowfHWzF3vqbK587nWMf9hMSb0pESwyQBuTLvXkGIqJ18e9hEnK672iInctnbmT%2F9vJOYrOHi2YCJop%2FSztFmvxYui91C0%3D&amp;X-Amz-Signature=10235e287fad1dd5dea55f45c696a5b38c45d4ec0b94992e9acc2b8f96091638&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="657" height="332"></p>
<p>사전에 Jeknins 컨테이너의 id_rsa 공개키가 github 프로젝트의 Deploy Key 등록하는 과정과 <a href="http://github.com">github.com</a> 의 RSA 를 추가하는 과정이 필요하며, 아래와 같이 저장소 접근 방식을 HTTPS로 바꾸고 github 자격증명 정보를 추가하는 것으로 대체할 수 있다.</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/d885f620-dca8-4623-ba62-c3497d97c89d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45ABTRYJOK%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T054735Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQCxeoKyaQJalwwzCpafL%2BXhyBUmtUy6mdJS5MyD0oskeQIhAKZmG2aSw0S9hNWow533VYGC1Lr7Ifgow08UIK6cZbRVKuMDCM3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMMjc0NTY3MTQ5MzcwIgxnd2HNoDd6R9hzWLAqtwOC7BR0%2F1f3Ly5UfXFAk8PEDvF5zwGJmYEakAhEwdTTC22yqRjCAW29OrTsaXU5pQjTPbQU5KpgpAHtjR2IS3%2FUc6PLYIYsExzPMoiN%2FYejmElTNEnfH%2FRCuwCbEl%2BOpAp3IjXP4CSYValjI5yzwQ7HptgnaMLYQ0NoIhhrbSG8EI%2FVpWxPrry5uQ2Zw%2BG%2FVHTnAZS8XCebaykmBmoE7sxrZzW91AoinyKb2tZzfOY57V%2BuOtoBCKYY6SZG7KE77xMGs380rmmO48oGzIQ6uWtNNsA0Oid6ES0XO0zra%2B%2FyaXeJLxi0ZCGPlAy8qqiwOZfNrlmWS6N3x3I9a1Lm0oIs9Z8EYIGEcfgKKck9Utvp%2FrpFtuUTe62398ymOsGg72L9qMqSoHTMz6N3rWqMf%2F151QY5W35QfMUMK7ncgQV%2Fk%2BlqfiL6X8rAeTrYeGjCE045VwOZMUN5Bb2cb0P0%2FI3gmnQq2W%2FljXSK6v%2BQFQh2vBSLuNMDFZ08GERjrxhCJxM0tX%2Fh08mAbRjC1VNXymLNTHSp23kJVHbiNLupbpN52oyfhl7eEEXAqDqLbOk78gcdJZrLd6zzMIKRh%2BgFOrMB547%2Feqx9Sv%2FBk2dQtgnDFMsrQR%2Fv0Fj%2F27xASU3oORDADzY39lWfx9JgDpxNH%2Bmmc5M9Ivi0ZUjbqNtjE0liOtusomC%2BjIf9PmYm4%2FIrICgNmKjlbQVidQxYc6X7mZDw2iaZbDYjLtQgmp3NKIueJlTMLHLu5iuiJX3CBAwLjiHjeTQezyT1PPXlffgxEMW4RuR0sVT6MCi4%2B9Y3%2FClM18tvuxTnqOGDgI%2FQQRdcrh1SYPY%3D&amp;X-Amz-Signature=8f189f28c3782847f5b2eeb960255ae902f4be59530bb4bf51b5f38aa71d06b5&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="657" height="458"></p>
<p>그리고 자격증명을 위한 인증 정보를 Credentials 항목의 Add 버튼을 눌러 추가한다.</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/68aeed79-f8c3-4393-ab32-54f5f90b179c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45ORZRD6E2%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T054751Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQC5PGWHN7pdQ%2BYris2olP7O5jV4q6QM%2FDvn2wv2sWb1LgIgRif5U02KZZ%2Bd7uAZpIGORBm24lvn4mWlBpqeEv15u8Iq4wMIzv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDDQSmq5OKSYLtnxakCq3A0l%2Bb%2BXgb4aEEoMhMH%2Bu0t6fZlaa0ZQvp5WcgVZ7Z8yCjrXsm6E917NM96p3gEvFaz%2FW8k%2BSCj7aHe8%2BMb%2FZQQiXM4pagdgdlCBAzUpbI9KdaZ4l032wvqWSaA51bwqmwXh7q2vZaIcD5lj34clpQWcUXOCnqhDi0ENij5%2FXCX%2F1%2Bu1IAskQfUhAgHnl0aR1Ll9iUIXDXI1RNO4P6fFq51ow2HAWeqIkPZgHYt%2FsI5zvx9PLoZZU7vepfJ2tt3t%2B7WLsmvH9KV0TyFRVbKLVrHzuMhsfTVE565D2ygbdCNnJXi03SRKOg3oTg4bSX2KyaFUKkoYoC%2BASQ6JUDoikBzqpSJNabCbupP0G1Hj5oD8DW%2F4g2RJXZA0b8plsD4MsNlPm4qECCuhFEktBqFcouk5W3Gd5cwxV8VeA6stOgimOvnvHL9LbfymkhQBB00hZMY3WZXAxQoxK6P2JnJWESJALstBA2H2DwkxvW7IzDveM1qU3L%2FsrMrqSWTRrdt8msX8NUi2Jg76n7sielWmEhFbwGb1GmQA1XAhm4HaTL2F7inV151NdKED51pmQZrw%2F0NyjykDyTKMwurGH6AU6tAF4v3skS6jduhFzNtRfckyZySRR4Zsr1u%2B8EFAg7zx09W6idnNF10HBvDuJLfBz%2BVsQKrsLGV0IPSDm0bUVtHEwZTYg2tvEPg5LWAw6UvHNEZ%2B%2FbSqQ1JjkXBv9s89wDyctfBkJLjO1fuBr1mddA0o61X7Fw0bNOU%2F58Zh%2BtcEMcp1sVFkzkIIN5vE5fqFm7tuxGh3E%2FcHddkMJ0dP9mNYyCi4xJ1WAskK31y1ZBqwPAN8Z1ow%3D&amp;X-Amz-Signature=7f423af8cd9c293483dff7419c438801c1fc79340b8dd5d94bf0214f807eae21&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="657" height="372"></p>
<p>빌드유발(Build Trigger) 탭으로 넘어온다. 여러가지 빌드 유발 옵션이 있는데, 그 중에서 '빌드를 원격으로 유발' 항목을 선택 한다. 이 항목은 Github webhook 과 연동하기 위한 설정으로 다음 챕터인 'Github Webhook 과 Jenkins Build Tigger 연결'에서 관련 부가 설명을 하겠다</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/26a7b38a-54d4-4b6d-a91f-5c2045ca67c6/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45FAJ2HRVB%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T054814Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQDRIhcN5mlX5FouUlc0r748ZjkXV1h3MV68aLVCfQFhOAIgb1SAbZ6QRJTmH%2BdRK7kGX7CbvHT%2BKMFOxNjprr8XcYAq4wMIzf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDPdpKHdRXU%2FID1IPNiq3A4C53NlrjTjh3GluR4JZ8ZLHETIaQhc5n465j%2F6d%2BEDYoAUyxRJ9CHa8%2B4QzTTn2Jptc%2FXLOGidFTqn7D%2B1jJFOHJ2g0KnW7rTZ5Sf0uTJOzixfj7HSP%2B58DAsjeq4tWMOcjbH1BbZbgL9CPFqiNOfvgW3fiSWshQ8rcYjX%2BtqwOR7T7aJmPv1%2FRw5VRtDfnzraowWE0iUfIg%2FAAF1DpcG9mj0OWyJqZ1VbsmFeSlxk%2B5QNvXbcV4OfkcUF1p1RtrCJf6WZcemFJpJK6BAb7IfXqwZtx3T0VSj%2FBL1EdwH%2BSqlQPQVgEpvnaxMCCqRJuax3wbD%2FepOhKyRL%2FTVsBbwUrpOHGFygoOX6igsdqdPmkDcM0DLrnikWkgst5gWkFaRoDtXGaMthRHK6a0G2q2wkK3m4ElNjnqdp7H1UWCpUhGhMJEt3LvbTY6F6sHCgIUMaSmCxZ0qzvxUXGhox5vymDFeTw70pUzyGjl3V3JI5AdEnnJr6Oos6VXvD5XQatSVaP6RhzArtNxm%2FCJcSLfZGGg%2FZzXC69Rp5Uva2DE5tKwcnblXn18txVjko91r62JwBKDy7lZCow3o6H6AU6tAEdeuKzK%2FcxRYUj2NSk33TG8j%2FA3q0BRl9Alv%2F%2BvcPMuksy2yHzDSFSyVmtONvpld6cre%2B6eN0XZNV2iovNgAysWQVAtKEXPTIvUPgK7kGFvNH3UzCvztxDIRVwuooKDk2pAE%2BtIVOHPwCjTuMnMxHMf6doj5JI7o%2FYalfPfl1I%2ByYBAmB9%2FZsaclSi%2B8tea8px0CfnQcnYolYnKhJy0pcv6jxW4fTb6HMsiyDzu7gCcCRud3s%3D&amp;X-Amz-Signature=85895d6cdf80a0a94601d45913be19982dc0f79d58ba8778259ac2e55f837512&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="657" height="261"></p>
<p>빌드 탭으로 이동 후 'Add build step' 을 눌러서 'Execute Shell'을 선택한다. Shell 명령을 통해 빌드를 진행 할 것이다. 빌드 스크립트를 한줄 한줄씩 작성해본다.</p>
<p><img class="post__image align-center" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6eaba039-0da7-448d-aaf9-d034c465e174/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45M7W4YVBP%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T054829Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIAg%2BDlhCDsuaUdJ0hlwxJVi0dASnnU%2B7a8Kr3z7sk9eWAiEArez8kvkw4HkMle7NDg7VhonlhGkPxHJPWq5zEOezuAEq4wMIzf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDDetiJidJdcYbnYcpyq3A2VTd2GH3LDw0PMA2vH5zqK2%2FJAhG37t8S207TBu%2BJUkKqQJZK5glAQp0I%2BZ%2FD5FVj0jRS4SX5KYrm7IQX%2FRlNAZN9LMVPUtiy1eb%2F7MsE28uF9si3TTeWE08iL7%2F1q6cLxaZARmh2ZSNmOiRbT9slsqTlSGMKegf3w6n2RZ%2F7gVnsF%2FbJxtfaGJqw6A1Q3WOVGrAiJjahYgTXUTfL7uBAgypDJNAFw9M0pRzJpoc1w3fVz8EQ8r5O5YEvMgYHg30WsqCzyzEFnPJBqdzzx3l8dtEpwTS4oWKsGw7CWrwWiT1KabEHx%2FDLtJxSFqKbsPu%2BtlDI6dWWQTMs6POuXPntz14%2FCBKkGDMTrG%2FtuwJtS1CfCprrN9EJ5cEvl7t8GRQFeV1r8nztmeSifVGUjf5biadgfIotxzpseA%2Bfu2d0%2FZT7Sa328LhEHItKvAlgswCdY2U2DYZHpoIertZVRQnBPvPAUF%2BqlQpHcWf8PK6oNL30TZX6Q3ujoGV8Dp4g%2F5PdcSiEYkILWoC8ig13qdJmHoG51zXgmyMr8mL9L4c939K%2BQ8PidE2oQv49ABZJlwYKrguVUkRHowwZuH6AU6tAFOom7MZCYTxCyqkmLKk2PBhGAjsbnvUftM3j7PyHbSk6%2B8ZMEuAmP%2FKLyxmJHgQBKH0qBd46I4NpmEJu9H5E2dMy%2FG2US7GwDnWeHaXjKs8oRYNJ5ivJ9OxJxZy6lvbVbApoz2OBVjKAF9bNBJc7IWzFe%2FiR6pRckX%2B0%2BLv492Te%2F0xEN590O%2BP8JzbkInMizKP65aJa0aoK2hTkX%2F5eTmOsb%2Fjo%2Bwj6PrH4Ho0YIkgyyfdrE%3D&amp;X-Amz-Signature=8e18c34f093ceab6c2ec1575d4f5fe58dfacb461a5b67b95cabe359ffe4e1ba4&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="346" height="308"></p>
<p>빌드의 전체 과정은 다음과 같다.</p>
<ol>
<li>dependency 설치</li>
<li>빌드</li>
<li>s3 버킷 비우기</li>
<li>s3에 빌드 결과물 업로드</li>
<li>cloudfront resource 무효화</li>
</ol>
<p>우선 package.json 상에 추가/제거된 의존성을 설치하는 명령어를 작성한다. 유의할 점은 아래 보는 바와 같이 실행 파일의 fullpath 를 다 적어주어야 한다.</p>
<pre><code># Dependency for SPA
/var/jenkins_home/.nvm/versions/node/v10.16.0/bin/npm install
</code></pre>
<p>그리고 webpack 빌드 명령을 작성한다. webpack 빌드 명령은 앞서 npm script로 만들어 둔 것을 이용한다.</p>
<pre><code># Build
/var/jenkins_home/.nvm/versions/node/v10.16.0/bin/npm run build
</code></pre>
<p>다음으로 배포할 S3 버킷을 비우고 빌드된 파일을 업로드하는 스크립트를 작성한다. (AWS CLI를 사용하기 위해서는 ~/.aws/config 에 자격증명 정보를 넣어 두어야하는데, 이 과정에 대한 설명은 생략한다.)</p>
<pre><code># Truncate Bucket
/usr/local/bin/aws s3 rm s3://monospace.kr --recursive

# Upload Build Artifacts
/usr/local/bin/aws s3 cp /var/jenkins_home/workspace/monospace.kr\\ Test/dist s3://monospace.kr/  --recursive
</code></pre>
<p>다음으로 CloudFront 배포 스크립트를 작성한다.</p>
<p>CloudFront 에 배포 할때 각 지역 엣지에 업데이트 된 소스코드를 반영하는 방법으로 invalidation 을 이용해서 캐시를 갱신 시키거나 default root object 를 변경해서 새로운 버전을 가리키도록 하는 방법이 있다.</p>
<p>invalidation(무효화) 을 이용하면 빌드 설정이 비교적 단순해 지지만 할당된 무료 캐시 무효화 횟수를 초과하면 과금이 되는 단점이 있고, root object 를 변경하는 방법은 빌드 설정에서 index.html 파일의 이름에 해시 또는 버전 식별자를 추가 하여 생성된 root file (ex. index.a34jgkh454j.html)을 CloudFront 배포 항목의 Default Root Object 이용하도록 해야 하기 때문에 빌드 설정이 다소 복잡 해지지만 별도의 비용이 들지 않는다.</p>
<p>예제에서는 Invalidation 방법을 이용하였다.</p>
<pre><code># CloudFront Invalidation
/usr/local/bin/aws cloudfront create-invalidation --distribution-id E135Y3KFO54CPN \\
  --paths /index.html
</code></pre>
<p>완성된 스크립트는 다음과 같다</p>
<pre><code># Dependency for SPA
/var/jenkins_home/.nvm/versions/node/v10.16.0/bin/npm install

# Build 
/var/jenkins_home/.nvm/versions/node/v10.16.0/bin/npm run build

# Truncate Bucket
/usr/local/bin/aws s3 rm s3://monospace.kr --recursive

# Upload Build Artifacts
/usr/local/bin/aws s3 cp /var/jenkins_home/workspace/monospace.kr\\ Test/dist s3://monospace.kr/  --recursive

# CloudFront Invalidation
/usr/local/bin/aws cloudfront create-invalidation --distribution-id E135Y3KFO54CPN \\
  --paths /index.html
</code></pre>
<h3 id="mcetoc_1dd7ln67k6">Github Webhook 과 Jenkins Build Trigger 연결</h3>
<p>Jenkins 의 보안을 위해서는 CSRF(cross site request forgery) Protection 옵션을 화성화 해야하는데, 이 설정이 활성화 되어 있으면 github webhook 에서 jenkins 로 빌드 트리거를 실행 시 No valid crumb 에러가 발생한다. CSRF Protection 옵션을 끄더라도 Global Security 설정에서 Anonymous 에 대한 READ 권한이 주어져야 동작을 하게 되는데, 이 경우 외부에서 누구나 jenkins 를 열람할 수 있게 되므로 다른 방법이 필요하다.</p>
<p><strong>사용자 추가 및 API 토큰 생성</strong></p>
<p>원격으로 빌드를 실행하기 위한 사용자를 추가하고 사용자의 API 토큰을 이용하면 jenkins의 보안설정을 유지하면서 github webhook 을 받을 수 있다.</p>
<ol>
<li>우선 사용자를 추가한다. 이 글에서는 builder 라는 이름을 썼다.<br>a. Jenkins &gt; Jenkins 관리 &gt; Manage Users 로 이동 한다. <br>b. '사용자 생성' 메뉴에서 'builder' 라는 계정명의 사용자를 생성한다.<br><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/13b12edb-bbb5-4d5d-9dc4-a7374bd162d5/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45AJKHXKDT%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T054905Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQC%2BZTqeQRdz58O6JFT7zi1%2B1fFDJz0i%2Bw8BFJ7VrLBDbgIhAOyghmH5qLH5O9Z9doTttm3l9ny45vg1PsKoq4zcKkF8KuMDCM7%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMMjc0NTY3MTQ5MzcwIgwPNLD6K3Fbw%2BGdRR0qtwM1%2Bo43q6LMIr92jNxjPsjCnDMcp09YEsURNmo0IquvOgqI8TsDQeQVjIVtFKn69HiovzaOOpD0rpvByFzSl5QtWgT4FcLZNw63JkPDsCsrkOgMX29pFtvlKyrkei3tz1lXX7hf4FsNcCOB20CfVCbzhwEgH2l2n79Bycqm%2BcFtIDENfBZIAmfTgzOAsCms91w8nUGFI%2B7neW3%2Fqagr7kHcRf29RJatAO8okO%2FZMKUk9Il0Kv8qeO3d9nPhpC8fkc%2FosvNtLqmKY4jvi5HxahKZ3lgSqZLY0TgaFD2J0xc6WauA6uFHgawbzUnu33pNPcGo%2BDRgGszkkpTNCAgKzozbsqqqMCZuzlj6TBODT9ztaM46U%2FZd0dgBX%2BwedTaLqOsk5Iq4d9qzFMRljFE%2FkIQxZUM3vIcuOKzhaOStAywg9ti8MYErvU5OZQoXZXMW5yOUX8jJ387vk8zezQBVCipiz%2BmFJJnhKBFALPTHwTKcEizwLpwDnJP%2BabFxn0cTSWQAQYPtCg58elRqP0FHO35T1b2goCdwnwlHoAgmftwUT70FnrG4m7Lcc068em564vyqxFIU2i3pMN%2Bhh%2BgFOrMB%2BrY0%2FzBcL1g9gFdPrTRAALxEg2fU%2FSgeam2xpU2bePTH9W2Hn0jIqRGBjugm5n3G6D8N1vB5Cm%2FHI0cBMM4qD248okeHFQzJRcLllqJVGOEZmCBjKkfX5cLTrfPnTuEp6Xjylq8j0NYShfA5PRuynlmqknWghd6BaFrmjXbR3uvs4KHmNfwbiGQfTLznGA%2F17klfUip%2FKwNPvGaW%2ByRH%2B19dG9OwgBKPqwx4s%2FrdskG1Fp8%3D&amp;X-Amz-Signature=faacdf84e2864d32aad23b3bf4b0ca293b2def4e21fa129d04f51af15d24de8a&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="345" height="258"></li>
</ol>
<p> </p>
<ol start="2">
<li>그리고 builder 의 권한을 설정한다.<br>a. Jenkins &gt; Jenkins 관리 &gt; Configure Global Security 메뉴로 이동 한다. <br>b. Authorization항목에서 Matrix-based security 선택한다 <br>c. 'Add user or group' 버튼을 눌러 아까 생성한 'builder' 를 입력한다 <br>d. 'builder'의 권한을 다음과 같이 설정한다<br> &gt; Overall : Read<br> &gt; Job : Workspace, Read, Build<br><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/cae86162-ef92-48c2-a314-b64695141b13/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45M3BJYRAQ%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055124Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIFdkPGMcz3iFI70tJdXeawkDPNpI5zFJDhR%2BKJ%2Bet2OTAiAodl3rQmdcFMDxn%2FB%2FpsD8NZZpOberU9wgcMENwgAQrSrjAwjN%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDI3NDU2NzE0OTM3MCIM7me460rpNZPF7%2B4OKrcDen%2BTG%2B7mGmRBIRUFOVCbHll5zacpLawvn%2By9WDE9SmdGIWD0iJsCj%2F0xiSCA2Zv8fwaEywpFLQlX%2FGkD6XtsJFX3vfRqDyKU2qHUouKGkdR6yRC2QdpeTR1R41mUcipkZU82RFe3oLEQBNDZR1Z1jMKlHZ0LKJt1%2BNiRq2srrKZ5ntTGjZIUwnZ432gbltjpNRn44%2FUd357wLNa4TetsPO8EkdujC8Iv95mq1z6Dn1OEsCCr0fPiShtaFzwpG9cTjJ847ra6SBGNIzMQl914csyHNfmy7%2BASLbi77baldYiHn%2BNvUYVGW7koH1pC3IN5izYiNXyb9sO61K2OMDc4HmyGdyIpVNEuw%2BWa%2FTezgWpqGXfs4zKeGcalGxeExSjehmF7OMIyeFurzqXrtvnt%2FxCRNueKeb3yb4TTT1365SioqvAfEI7k%2FC4A5s887Ge34qUgvvKlsOn0tfKUAz9ez9zZHWzbkWqtHw1854ECxHtRgK1Mnc9Rx4TQesOhIjv%2BqNifyBEO8Ee0A6Qi%2BJG9UMmMDJoc%2FOb%2BtXFdK1iWEtIxjWVGUkBXBGjHyWBM%2BFz9OZLBlAVVozDsjYfoBTq1AePU18sihKFHTemixpLCwPBlM42kCccuX5tZfxiSBGGeL%2FRItWepgEEkBwC1bF76KthO7D11y%2FwvHefq3e1UIShdLb9AnlG3hlD5NwCK2WgAV6IpZ4oNHHXCc6V%2FgWCOSL3tZoNryET9hCuPFT6I3YUhwpZ8q5dKvvEhuWq%2B2q8a1o2A%2FL7LvNjFs%2FS8x%2Bzzz9H7e13fu9cXu7vJ4C9tx5SzGp%2FxnoffhCeXcIflDKgUS5rtX2w%3D&amp;X-Amz-Signature=c0d1b3f960452b0203359897bae4ebf2752d3501a4a91aa19fc10a5ce2323799&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="590" height="350"><address>결과적으로 이런 모습이 된다.</address></li>
</ol>
<ol start="3">
<li>API 토큰 생성<br>a. 로그아웃을 한 뒤 'builder' 계정으로 다시 로그인 한다.<br>b. 대시보드 좌측 '사람' 메뉴에서 'builder'를 선택 후 좌측 '설정'을 눌러 설정 화면으로 이동 한다.<br>c. API Token 항목에서 'Add new Token' 버튼을 눌러서 토큰 이름을 넣고 Generate 버튼으로 토큰을 생성한다.<br><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/228a9be9-5269-4f78-9749-d443845ecd62/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45C6D7RG4F%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055252Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQDInBzHejcYecMVOKk%2FmDDYbn54ddpcHzZTG3Qvs9X9ewIgEu7VD6qQZpbv41kg9KoEzII3AzNYVlaOF1rnKH9yeg4q4wMIzf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDBVg0MGavANE0s0y4Sq3A9IEyqqXFPRQwtPOSsk3%2F1uR5jd11WzUvlmXtOYtxhvgVDoCfDuAeWhMvqBX%2BHGx3%2FmaiikMWKPw0QLA9BVILNbFutxVyJOiYBvL5B5f8qyo3AkKgbnf8k0IM24MK%2BBEcBLil5VDQXgvWhFWYDrGwjk2GhIm%2Fki41zj2wFg2ywFP1zgNDUhiljaWQzEvKqetCDS0Mnx7%2BsbGMrDHZIfdOWmISfcKT4KEOjqMDV0rEQE0ccgTR0%2FXd9UGKOXm%2FU2LinkR3IRkG3%2FAcvA7ls1qPmnaaTZ31u6Scf%2FjjXo9THKhkhZkdA1ctF16yMTMZKT72fhqLH8%2FZWVc3NxESMEBxQh%2BucBkjiEGse3e0ljGdhqbNOCFYYqsBeIRUATLI%2Fs2qEQ6pscuiEXg8ysX5GedjqdHYAtufKi5rPNLg1ach%2F%2F%2FycJGjngdC%2Fb5Sl07kSgG6hFNRmYCpXFSyQsjS2hIKUcH3dMKahYEFhcyiyqmmIQA%2F6tn16eQUMZdPrFinI%2BLgwiyVwm4%2Ffj3%2Fk6K99jOZn9HKE7m7nuMjeNvxFqr3vVo%2FFFZDWwxIQOMZszIBuObFPQFohRmCE8w7IyH6AU6tAEoExp0QxbyV0ZrgftgxSEvOnPK8iZEz%2FEGBsBvvF6adoQwCA6zCvNbk%2BDbeybZJZlVrz%2B5j%2Bs3ZxY4Mwu2IEqD80TcuRBzQlQtXeRUzys%2FgLWE%2FeU1Nj3hXofeiN80RDXTxSq32%2Bb0iZBD3q7WmpG6y8n599%2FIGIOskRnii0cPl%2BMOCQcFF11gspVn64AYyjJHyJa9w%2Fo84rTn3fL9yG2LPplDgtUjWL4yZTn63fzuEnTNqRo%3D&amp;X-Amz-Signature=143f02b21f6ee785b4874934d0741b23194791c87c52f8e4dd11f968b7852505&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="594" height="144"><address>토큰 이름은 아무 것이나 해도 상관없다. 토큰을 사용할 때는 토큰 이름이 아닌 계정명을 함께 사용한다.</address></li>
</ol>
<ol start="4">
<li>빌드 트리거 설정<br>대시보드에서 프로젝트를 선택하고 '구성' 메뉴로 들어간다. 그리고 '빌드 유발' 항목에서 '빌드를 원격으로 유발'은 이미 선택해 두어서 활성화 되어있다.<br><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/1811494e-a84f-4814-b9ea-ac35cbaa45a4/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45KDPO76YI%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055343Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIHWptpaKJ9pQC%2BKQORU1ncBAIlubXrAh%2BtFoWee7WX9UAiBqXbzfkN5DxtD0X5RQwKkRFq0Gq8Pn%2F51ekctGctKahirjAwjN%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDI3NDU2NzE0OTM3MCIMak8ESbAHFsDdTA95KrcDkqLTsoc33zRkwxVAcI%2FcFsr2midjoy23HaG3qDJmSX1x6ok2u%2BA%2BtUuXoplHJozJns0x2wn%2B%2FG9AcT1Wy%2BwbEqBGMv%2FDsAE3e6sz27ZcfpTNn0zcW6d1gLekT6C%2Bv1NROJfybngVUJv5svwn3Ysfbw56T8iWkf3w4a%2B1CM4%2Bwj40Shie24EgJNEajC92ZXX3sbGSxs9suldv2Svw8QFFME7uzxN2eoS1GND5okYu%2FdPo8R6Di%2FhHEBlnwaJk%2Bj0EpLWuMU04tQK4EQl8GZzti8UJ3Y6vdQALmB4qhCC5rAWR39XkRuGlG63Y4VYMfbChS2ax5bMwuaMah%2FMetv5s4ZwbY1Lefcn1gyUB%2FWj8W1PpQ3hNopyGc7Jn933Nsq160Aasm6pzXZbW7cu73RzrvtWkdlXXFsx%2F1EZcmEIBF9SUokgLpEiI7YzOdaezdVDV%2F49TOof5T5iqqlNI4nuxP7VUZ%2Fk%2BcGzrh8dDsdnGK4%2FSBr3p6XgvTbEoICq8pI2f0r7P76VwqkbroLPU6JNl6zgPLSw8sYkeSpS81EkmB%2BGU9LT8Q6mC0kJeNNMAnRPpLJIQxRFRLDCQnIfoBTq1AYX%2FAas7Psk4pyqLRq%2B%2BYMvSP9xL8%2FxlqUowps9oh7mTjAG989cnkcYh%2Ffm5a%2FJWSpK8c3UpCChv0A4rg7gPqNep%2BIMXiSwprrL26PNuzqtKcNha%2FD%2BQvACfO%2FcBLRDrEUvWD2txRuzMQ9oZIYuSIYnOkbQiCSCaONHU8xlEqjYyTGD2uYvKS1b%2Faw6hA2GGdQrdreaDCN3ndGXD9B48YdOdlha%2FUqFjMMHk5Cc3P%2F23IFnl42I%3D&amp;X-Amz-Signature=6abb3b2e4bc1f2605ae468475e64819a188885a2aa06d41105c7ae230a7f12ea&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="601" height="173"></li>
</ol>
<p> </p>
<p>예제 에서는 helloworld 라고 토큰을 입력하였다. 실제 사용 시에는 사람이 읽을 수 없는 해싱된 문자열을 사용하는 것이 좋다. 아래에 예시에서 보는 것 처럼 URL을 통하여 빌드를 유발시킬 수 있다. 필자가 테스트로 구현 중인 jenkins URL을 기준으로 다음과 같이 되겠다.</p>
<pre><code>&lt;http://ci.monospace.kr/job/monospace.kr%20Test/build?token=helloworld&gt;
</code></pre>
<p>하지만 이대로 URL을 호출하면 앞서 언급한 것과 같이 No valid crumb 에러가 뜬다. 이대로는 github webhook payload 설정에 넣을 수 없다.</p>
<p><strong>생성한 계정과 토큰의 사용</strong></p>
<p>이제 앞에서 만든 builder 계정과 API 토큰을 이용할 차례다. Jenkins Host 주소 앞에 &lt;account&gt;:&lt;api token&gt;@ 형식으로 인증 정보를 전달하면 정상적으로 빌드가 되는 것을 확인할 수 있다.</p>
<pre><code>https://builder:114bf74b38dde25c8bc7db803785cdf432@ci.monospace.kr/job/monospace.kr&gt; Test/buildWithParameters?token=helloworld
</code></pre>
<p><strong>Github webhook 설정</strong></p>
<p>Github 프로젝트의 설정 페이지에 Webhooks 메뉴로 들어가서 'Add webhook' 버튼을 눌러 웹훅을 생성 페이지로 이동 한다.</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ec777b4d-ca9d-400f-9903-27b1e3a49c7d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45FYL2VKSX%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055455Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIGirPfqydgZ9ASUrhuNssyA%2BJasYZwDk4uY%2Bafx8PzfuAiEA079V3bDjcRi%2BgiZDO2PG0S5Fl6BY5qHd9azoTpPWecYq4wMIzv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDKgJ8TZK9M18d%2Fdzfyq3A%2FS4mEZMUQp3SAN5hlZqXlYgRd53QXfKwgBJ%2BHt4CHPQZmBHy%2BIZNjo8nA2LpXWRtkrFPNBQRGW7B8wXkSMeAfsQpzDEaFjBU7Ce94xExspEHupVtXl4zF6he%2Fq0hIeDhsN0Cnxe6Kf4CVyXq8wu0ZnZk4qWQqTXBZzRQEB1niCSpj00gNi%2Ff9Bu0T2dxxUFClhhtW9CgJ4YJedol936gStSTJ6USANtLr09g6bmDno277iHzk7k%2F2TEDBt5iYwlNfrPEje6SF%2BBBJmdRINyullMwwv%2BcHHbXPofLtv%2FZ3WRcmbXM64A06XTXaj7jKlhgrO2OHXMQe4I3GmVQpF3swNaGKzJyKBflnT9F3iBShuhDQdIXYj6NQBB0RDOSXbOmVF%2B30%2FOYjP%2Bv05dMQDuD6hUmoLpjrmCpQEE603sc1yPOZYUNEvM%2Fwr0%2FZIKnJZl3iJXkEGxCyxk0%2BcTqXxDosvqwaD6eLPO492M3r4GlXQpdMexZ8kr0I1nSIt1bEbMPV9amBr7Ley7BHYdmOVfXJTlrPSzot%2BJcJhcjj2X8uly2FiiZdJx50ayVQ4DliS%2Fp0mEEGY7iFMw%2Fp6H6AU6tAHo2%2F%2FX6dd1Lj2ANMJuQKhjpJ7KwVVfDqaplRKM1WPHwjQitgmS2nSYKMyOxs61b2%2F4PAe3O84scqIFC%2BKPq1e0fsoh9yPHL7BoyPNdNpKdsIH05v%2Bp7XTwXNzOiGX22DZxF3twRMO1%2FCB7%2BUBjsxXxfWDDcYzrZbAaEvtiItpa7cxNJvZO7JnzYB5DEME%2FBVbMqkzX0nift%2Bzq4kffFYnM7TAR2oDlWVCGpKQ%2BTTADAOPBm7U%3D&amp;X-Amz-Signature=156608d7361460ac3c42238e46f910f9352b7c310ef206d9dfb27540792ceb2d&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="636" height="185"></p>
<p>앞서 생성한 빌드 트리거를 Payload URL 에 넣는다. 아래에 설정 중에 글에는 다루지 않았지만 필자가 Jenkins를 구동 중인 서버는 NginX에 SSL 인증서를 설치하여 HTTPS 활성화 해두었기 때문에 SSL verification 을 사용하는 것으로 설정 하면 되지만, HTTPS를 지원하지 않는다면 Disabled 로 해두어야 동작한다. (물론 실제 운영 환경이라면 반드시 SSL verification 을 활성화 해야한다.)</p>
<p>그 아래로 어떤 이벤트로 웹 훅을 유발 시킬 것인가에 대한 설정이 있는데, 상황에 맞게 적절하게 설정하면 되겠다. 여기서는 푸시가 되었을 때 웹훅을 유발 하도록 설정하였다.</p>
<p>이제 아래 초록색 'Add webhook' 버튼을 눌러 완료한다.</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3d530162-956e-44d5-aef4-e6bba1dc4095/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45NCD5YIVP%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055652Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIEbYpM%2BVynFeSNgfvkHqNEBWj1CgvAZdxYZ3owGo8QPsAiASNI8Bdfx7ySPAV6xd69vudwvrp7TzQEDOGSlXUUMrUCrjAwjO%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDI3NDU2NzE0OTM3MCIMgJMCxy6a%2FgWfnvZ0KrcDItzEjovqVXiyeMeW8WzPUgOtmsTBh8xsmpswjPBcj7KSEAaU5X42XNpwbiDsQXvxvfh6w5sqMep1tYcCMgiH0Ue%2BfMV4Eqh1%2BcpN57IWbqfhURVdQCZSuuUTGoG3oHXkfceOhJ859A9b6BayVLMw4TlYdKjVdSn0hIOGYLKcOD%2B8pfEM1E5yQJvOvJW1CFNIv%2FTKOAZK92TuwF8s%2FK6MQebc3qqV7kHNGpHeypv7wmsqcOPinXifS7m%2BrZJRaMnGG8romLqUPKMcCM0lZyruL1ILmQ%2F11HFRnkvaMlb42U6%2B58pcsyFwlvr8hUJF3sDklB%2BeJMdaSSJCOE5J%2FbovYtRf8ZIqItzij2jMT7I6%2BrWegL7g6Z46REncWxp5UNrokKzoSeJbaiRSAflyEY3yBy0NFfM8Poj9Goz73Yvh7aztFuzuQLswP58BVQKf5vcUpllz6mL8%2B5PgyxldyVOHsMFYk%2F8r3wRLve8IUV8o3Bc17GaDlx5c7nkU8q79EiLFqEPxvJvTokBt7DJQl0cxhV%2FcMZhGR3Ox%2BV8NAKT8X5mLleiZ%2Fad%2FjVL5cnAErze%2FRAjwzUOluzDap4foBTq1ARW1ZvlsJJRXx2F9MB5Qhp3gqjn5Q%2F1EBq35KWtI3cHFk93sgiKvS%2FY%2BGsLqIHYXl7tQxju5Db0rzrJSlnUnZD1lpTzWwfZRhHhRE10nVk0tcnAVo1lX6R0cvfuF0GxlUhYtuR2zchdZPMtLS0997lxSenGK9Gk2gEydEWZQoTlQXrALfcXed7izkjLD%2FHVC6Be5BiWQ1b8cvLbXsRHXXR7KwD1cgaA%2F%2Fw%2FW6dQ7VsZTFxsQevk%3D&amp;X-Amz-Signature=ef3ab27110681db28804f27ee731ca8a46fdd502347466dda82535968c796589&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="587" height="600"></p>
<p>이제 모든 단계가 완료되었다. 이제 로컬 개발 환경에서 SPA 소스코드를 수정한 뒤 push 를 해보자.</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6feb4df1-c79d-4296-93a0-448a90503060/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45KXN3KN6H%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055709Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQD2oHCnd5rL3rpZNQ4X2hjgWX%2B4oPpaJIh5EOjNBlPODAIgDvj9F9tU4UZj5MCRvQI2aBZqqFrOdgqNuDpduofckfkq4wMIzf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDOnozBCiZqQjWQBAfSq3A9R4cvbVaBn3TKV4feK6dEPXZBR4dTSRCJV7AkYSxOzynsk%2BYF2z%2BXTQlGbJSCX22lPbhHdjfoFtv6LQ5w%2FB%2B%2FaiC7IV2MmyszxXhSMVyLYSD6MMC5kqZAhwDl7VeVEebeFbsrpMCY2OlbVOeL4P9wTBiaGbdh5o1G6qf%2BYJxCiNmOjytKW7NK9d5B2O05zsxY5U%2FXEnWEWrXFvzYfEKgxIqOIndyj3t1fihVogAFFaK%2FMhqQLMQNGmKIqzYfOotn8SqHBs6bwfkVGk%2Bu1KdGfmCTBuMVILp3I93Qw%2FDJmtjE8HIFWS7Ouo4MwKppOTrNyoO%2B%2BEiSE05sAyx3L6H3RlFFgGN6uM984CJD0a5ah5MWp%2FImmgWwjns8jLSdFCLT31NOIB3fm4FOFmcjck8dOA2VpRZWhjG0DWWsgejgXwtHNnREXY7n4I1A5uebrP94wt9s3hB4DlWTAUDbm01lD7ZFjJWNKMcghqPx4mU17Ih0KJQjTdVA3N8HORJJopLPmP0smh6BazodP%2Fq5hzM3qBQRbn0y0VIc%2BnOM8rP8PLwRCXSJ2oHe6mqOaKP2Vob9OMrVHRORQ8w05KH6AU6tAFq25VKPT36iUx9S%2B1MBWFE29FIumZo7xFMDcz25icQ9K0ZDzaKvOv%2FfJQFhUud2%2Fmw9MI3ToxsgJMXVkStUjLMKPuHaU52zHMU6%2BH6NUc8hom4S6lblcTJirDl%2BgGg83flgixyNESJEjW0OEvUYwIzGQbCSEpIujrGU1b0o6T3rRUFDdwNlrEMB2kRSJRqokPAoAFPivAgJT6FD6BPZQcEqgOZ2uCQXMPwMY5HUP9hFtdlpqM%3D&amp;X-Amz-Signature=f1bf9d9342a60bfd3e4628717da0b4996016978e12fba1a6c89e280e359c70f1&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="468" height="210"></p>
<p>파일을 수정 하고</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/659e2a99-33ed-434a-a8b9-93e238855e8e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45E7ZB6GNQ%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055727Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQDCjbFSBJ0Otud2BuXnH160pkIv8QQD2C%2FR4fL0keI7VAIgf5SJnMTFNyjQaVOeBzCDEB8aLBH9mhnRldttTp4HfZoq4wMIzv%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDHI0Klleaw8ysSxLbiq3Aw%2BSL5u2lWC3XMsiAsl1mypqox9pqY%2BhlcYZKegu4UegUeUr%2FXvIcMNPl5g7O9s1R82MS%2B24twiIlD%2FCFYM%2B4o4I6TK00fL6SlgBFTv2XNLI5RqHZCevTHPdUpQnnMtS1pqyXJZHaYPtnMSxN6ixQputyoDeMOs8DQVczVncvTRQhVCISaRSmj6M2BivF4dWRlPAAFma1hnSAQgDzAI66v3jcp3YHegMdKhgVyI4uVwjokHixZMD9oRW0Es1n1ZnDdXlD4oNHLMDEA8cS2KrQR7xj%2ByYY6KWdc%2FB8mrTrcLL%2BWo%2B%2B%2BTIYE9g%2Bxc6BkwxY864pHnEHBPI1AoBSIhBxmvMzLB2IK1XnTtybR5tT%2BhvXdbN5isgnwFeFbhQww%2FcceMBQu3cmC6oQIIZIUxhpkJzGZ980rjpsckPolQZYkniNIJ3gNdDAW949MP5zZ12QDYdXMyBv3aeYogyAnU%2BkvHDVR%2FBjT8ph7kE%2BgABz4cSLxC%2BT9o8uvBJrJEZyU6g4I4Q982Rft%2FM1qiW0LOi2ngtjCS9Cv%2FoU9Nbo1fHztW3Dv1sDnYZ81hq7fcyzGBcsXYfiOQoB04w5J6H6AU6tAHb0yKjVcgAnMIhx2kmLy5jE7mpw46XsLhO%2Bg9UcifoHftz7K9pdts6yFO01W4FdoDIkL%2Fd1imN5HB%2FM9mHvA8m0Se1TPEqrSdeLRMSrX1D38V1SK%2B6imyVChTrK8ruFqrvhB5S%2F%2F%2FQJL8v6OC%2Fibu6ATfLrgOX8H32UqjQz0XIaq7px49iQsUI7I1mNtL%2BluhAgFg7EDokL%2BiV2t3fYooTYX7VRZHqxMx5rVWWDHByc25sSI8%3D&amp;X-Amz-Signature=c5f5364891420b4b1904d6fba3eed42bb960aa0f19ae0ba82af6e18b1c68fa30&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="561" height="358"></p>
<p>커밋 후 푸시</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/367dc209-bb15-4054-9cad-f2574e415863/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45M3BJYRAQ%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055745Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIFdkPGMcz3iFI70tJdXeawkDPNpI5zFJDhR%2BKJ%2Bet2OTAiAodl3rQmdcFMDxn%2FB%2FpsD8NZZpOberU9wgcMENwgAQrSrjAwjN%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDI3NDU2NzE0OTM3MCIM7me460rpNZPF7%2B4OKrcDen%2BTG%2B7mGmRBIRUFOVCbHll5zacpLawvn%2By9WDE9SmdGIWD0iJsCj%2F0xiSCA2Zv8fwaEywpFLQlX%2FGkD6XtsJFX3vfRqDyKU2qHUouKGkdR6yRC2QdpeTR1R41mUcipkZU82RFe3oLEQBNDZR1Z1jMKlHZ0LKJt1%2BNiRq2srrKZ5ntTGjZIUwnZ432gbltjpNRn44%2FUd357wLNa4TetsPO8EkdujC8Iv95mq1z6Dn1OEsCCr0fPiShtaFzwpG9cTjJ847ra6SBGNIzMQl914csyHNfmy7%2BASLbi77baldYiHn%2BNvUYVGW7koH1pC3IN5izYiNXyb9sO61K2OMDc4HmyGdyIpVNEuw%2BWa%2FTezgWpqGXfs4zKeGcalGxeExSjehmF7OMIyeFurzqXrtvnt%2FxCRNueKeb3yb4TTT1365SioqvAfEI7k%2FC4A5s887Ge34qUgvvKlsOn0tfKUAz9ez9zZHWzbkWqtHw1854ECxHtRgK1Mnc9Rx4TQesOhIjv%2BqNifyBEO8Ee0A6Qi%2BJG9UMmMDJoc%2FOb%2BtXFdK1iWEtIxjWVGUkBXBGjHyWBM%2BFz9OZLBlAVVozDsjYfoBTq1AePU18sihKFHTemixpLCwPBlM42kCccuX5tZfxiSBGGeL%2FRItWepgEEkBwC1bF76KthO7D11y%2FwvHefq3e1UIShdLb9AnlG3hlD5NwCK2WgAV6IpZ4oNHHXCc6V%2FgWCOSL3tZoNryET9hCuPFT6I3YUhwpZ8q5dKvvEhuWq%2B2q8a1o2A%2FL7LvNjFs%2FS8x%2Bzzz9H7e13fu9cXu7vJ4C9tx5SzGp%2FxnoffhCeXcIflDKgUS5rtX2w%3D&amp;X-Amz-Signature=22c976cdc947b178bb07eda426b94c1bd015c542801a3bc0297f3c4c2841709e&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="628" height="365"></p>
<p>Github Webhook 이 정상 실행 되었고</p>
<p> <img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/881b2361-9546-4ae5-8d8b-9bb3ebed55b0/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45ISDYGFMX%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055910Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIDPxGXBv%2FFlLEA%2B%2BmLJaWc6e6ZBOKDwUwCAdX4HrP8%2BpAiA3exqMg5z7x%2Fa%2FMJLeGseBjTeSqP0upuN1R%2FWeesF5USrjAwjN%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDI3NDU2NzE0OTM3MCIMDO1jycgSmafEkDAAKrcDkknrkN9ci%2BvXVCamEmcIyElnB7%2BYRoO3L1zbP28wojE7XE0ErR5MqFG3L8%2Ft8Sz%2ByOFRa2enyucioAeCaPJLArTYvv28C7LUUXowIwVG0G%2FpXyMVuliJssHP%2BfJMhHWw2htqMGFM%2F84jSd9OBSvLsNmqlLqQYN313aL%2Bo0TUj%2B0jOstwwrp%2FaUgYvPMpMRLO63CsPkU%2B6234owgM2mNRqF7XJ6XF4KtKNpe244WNIDVFTREsGKZ852ul7gbz5%2BJ0nXVpV14DvgqPs1ny%2BXrEzLe5axPl0xURAdTDlbeRhG3H059QthJqfiqhyt2GpwLyx8%2FeQ7DTPvVEiFr1z6aKPvyJl52vpsdWouJIt3mGtv05Z37YO0ZAfV5dVBN149nKrYkP2bEq%2B1GSbsImwdibpgzb4fP8rKk5yJc95XRmOkTH4CmkBPY%2F5KVE9WNTaSj40fFcIlgKEpTmqvQlpq8%2BTRjoSoUxsJx7TDgjWK%2FYp8n%2BIx5MWEA1cX52k%2B9OyBAFBssIMl9RIhEWN8tncepnwneDvUGiV5YdzjO2AAKrHq3TGaTFJxxCHUpJ16Tgx03%2FOl45%2BGBkOzCdnYfoBTq1AdfvVtmcmmDYyZ1ccPdEgsK6jDTnQxIA%2FAViBM9AgoTYGkTweOcAlyNxtk8%2FqgTCJXJrj8s1Id9d%2BAh0XVQKO6jYGc5Okg9T8RKs15Q3x6Stx1%2FyrAS5%2BTwYHE6qKX2ktoVwPNTQIdX2h4S%2FO7585q92gCfV5y9AbZJ69rOum6yNaItErOHxCD9ElVm5PPb6NDoHSr2l5BPuKnVQ9iEOuSaHMVITg2mITIoz8ayQs45oKkZ%2BUIg%3D&amp;X-Amz-Signature=d7e00a32107b9aadabbcce7146d10f991c9c27dc0f86c18706489608db75f105&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="627" height="351"></p>
<p>Jenkins 에서도 빌드가 실행 되었다.</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/408fff78-1ece-4e60-95b5-29276c9a2bc9/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45DH4O4N2G%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055926Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIHidA1%2BuWSeQbNlEUVIeB%2FAwkBpT4Z22BoblLNuVvHKJAiEAg60OrgUCbX%2Buuv6E06vSUx7n2zCvn%2BJim0m0%2Be%2BpYN0q4wMIzf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDAcZxeeK66TZxtH%2BvCq3A%2FZY5FKUk3hwVmVpU3ZflwZR6Ed1DHPgiFdor2nTOxQkqGta0r%2FtuMSEm9P5FIhR93j5PWZMvrDE%2F%2BTYG5%2F%2FrsJeUPZfwXK0%2BZaE9I0Wgh1r8A9bhJh02eV96exVLUrY%2BrnRvhKIgMmB%2FFRu3M7K31NlVGM83qk8GhhAfrspeRb9PeyqZnmeKhqJkdyQ82pXY86r1M5hQXS8Ke9SCmUw%2FR3aTb6yf6zpfQFWTIKJoADBYCOJOHob37bVb8I41knQZ1AP%2BUDUWHNRxzj%2FooGvXc4y36MtxqLnRm8hSFZzSOA3lbO45DuDBiQMOsW4UtTaVgcNIreg5%2FUQ5DGLNhzHFIlHNfc%2BPw%2Fp6gDIeot5hDG%2FDkCLP0g2ZpJhaRNJ%2FVBkBRoCejup5n8KSjS%2BSUuFPZ7%2FxURPOSEVVCMG5OZNHN3xpY5QWF%2B6O436tpBvdWj9Vm%2F2UQwqeVLDHFWjfmxv8Z2s%2Bh%2B5oku9QpXBPs7eEzDkegyLTUfIiKc6ziSAihS9S%2B7vV3AyRInd4DVGtIAfQcYGFbyBOhUiRExLfoj5n2tzW17Zv1h2fQpmzv8ox5dspCG9v%2Fah%2FVIw946H6AU6tAEualLR3TvJgX%2BIYMyT5ZfpBfZOIuJ8X7WQ8vw550I6c1ss%2FT6Tzqiu9CStaIquqC4083bQECnUZXyOfBqlhzOrxu77BNl58aIsbD%2B3MoTOdD8%2B4sprRcJTLK9qgSA6JMMvAzcaBFdz%2FcKZ9DzSkjpFu6UQHOzvKOvRhwgP%2B6qBnup41SWf9YNcEKpwuAqlA%2F1Oh9m%2Bel1DorNIV%2FNUgadr23Ick5X0fvqWc0oVf6f9MZhS5xU%3D&amp;X-Amz-Signature=04728ed5c328f4b6150f3cb7fc2d0ba5895b9c7ea06a5d97e62d9a332fa33435&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="631" height="407"></p>
<p>빌드 넘버로 들어가서 Console Outout 확인</p>
<p><img class="post__image" src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/280973b5-121e-43ab-8805-327ce1931385/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=ASIAT73L2G45OHZN7VNI%2F20190613%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20190613T055941Z&amp;X-Amz-Expires=86400&amp;X-Amz-Security-Token=AgoJb3JpZ2luX2VjEKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIGa3hOxmd6dQ8oVJuhpR%2BARKW9R35Fnq2a2Xvx6ppx0qAiEAo76Wls8xezfTd1PbHoDecY7u4tMlsvCNlga0mNUEc68q4wMIzf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgwyNzQ1NjcxNDkzNzAiDB7zzoQNQntspSOspyq3A92xkzpFaVJEBIxc1UnRQfjVGzFoTgLIglKBQNroLNPjSw8PeReVYQl0jweLDUf5T8tkZaWtTtnA8M4z4lqPBgh%2BpI8i15rsELJML%2FRTjmsAiAWg3%2FPWCCnbx%2BPgynCLyOB8hMXLeGy8mNjlc09gbSmFJNdN317ti9QnZqiATMbhhYwBSoisIuW4vpg8XKq2KSP1cRR2aFnyjJ0Vrllw0e4JUpCyhy6zmDXMazOGPgN3YTdC0hzGS3eo7HuPXbcV8ojVa0OBfIodn7poIVSoHV9MSI5mypVU7cobz4RiwamD%2BGFBvuxI6kPHAXaSMrvqLjRej1c40tjqWRlxLafK67YRkamISNA7%2F%2FmqCKLHvjpnjSCb0huAlN%2FUinB%2B77ncXj6XVfbDg5ZPaQKBJyu3R%2FKM%2BwbzaEAcNt%2B6x7u5dOGiMADe7i%2BAIIZNpq6RtA50w%2Fpx3hwj449%2ByMbjp20QzelUbxgZPbyEN9Tl0SP1312ZR99CupW%2B0kp2fI9Caqt4QGe2DyU1Gag8mfJeXgwJSj%2Bk2%2BSdUpaHcqYzfw%2F%2B5uwHRyfygn%2BIxKDduw175c4JMK9hjxvOHdgwl5eH6AU6tAFuNmY1Zb6ImgLxOBB7uil7XvyUGNOj1KN1AZsW0luooFB4INT6e2CHyRaNOnv%2FDz6PrLkGAbyZYAGeM6oz5iG1RC59NQIm%2BnTHSYL5vzD0j7HPXkNc64Lj%2BrMvZdsLFUyMF3MurqIMBI5DbP7dq5xSt%2BUHZPgxaY%2BxQhkAHFFaf6kl9FZmdTwjuVUO8CqAIqCppXaMgbUzeNsZ6I8Z4cEiBsw7Y7cgqvjQK46M3XEY1zP%2BLZw%3D&amp;X-Amz-Signature=48df69220f0466ddeaf3c985508a22efbe1329338715f6e28a86332385e372c7&amp;X-Amz-SignedHeaders=host&amp;response-content-disposition=filename%20%3D%22Untitled.png%22" alt="" width="618" height="266"></p>
<p>성공!</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>AWS Auto Scaling, MySQL Read replication</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/aws-auto-scaling-mysql-read-replication.html"/>
        <id>https://devnoff.github.io/aws-auto-scaling-mysql-read-replication.html</id>

        <updated>2019-06-13T23:11:12+09:00</updated>
            <summary>
                <![CDATA[
                    예상하지 못한 트래픽의 폭주와 최적의 성능 및 비용을 고려한 서버 구성, 그리고&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>예상하지 못한 트래픽의 폭주와 최적의 성능 및 비용을 고려한 서버 구성, 그리고 각 파트의 세팅 과정에 대해 기록하였습니다. 계속 업데이트 되는 문서 입니다.</p>
<hr />
<p>&nbsp;</p>
<h3>머릿말,</h3>
<p>웹사이트의 게시글이 소셜네트워크 서비스에서 바이럴이 되면서 예상치 못한 과도한 트래픽이 발생하였다. 우리 서비스에게는 좋은 일 이지만, 이러한 상황에 대비가 되지 않은 인프라 관리자에게는 재앙과 같은 일이다.</p>
<p>당시 서버 구성은 과도한 트래픽에 대비해서 Route53 을 통해 DNS단에서 두 대의 서버로 강제로 트래픽을 분산 시키는 구성을 가지고 있었다. 나름 서버 한대의 가용 범위를 초과하더라도 감당할 수 있도록 Test 서버의 자원의 일부를 Production deployment 용으로 할당하는 비교적 쉬운 방법으로 대비를 했었는데, 예측을 완전히 벗어나는 엄청난 트래픽이 발생했던 것이다.</p>
<p>부랴부랴 Production 서버의 snapshot 을 생성하여 EC2 Instance 를 추가하고 Route53 로 트래픽을 강제로 할당하여 상황에 대응하였다. 당시에는 EC2의 Load balancer 및 Auto-scaling 을 사용해 본 적이 없어서 빠르게 적용할 수 있는 위의 방법을 사용하였다.</p>
<p>Instance 가 추가 되었음에도 Route53 health checks 상태가 100%로 복구 되지는 않았다.  그러나 웹사이트의 접속 자체가 불가능한게 아니라서 추가적인 증설은 진행하지 않고 두었는데, 지금 와서 보면 이는 잘 못 된 판단이다. DNS health check 에서 가용율이 100% 가 아니라는 것은 분명 어딘가에서  트래픽을 잃고 있다는 뜻이기 때문이다.</p>
<p>트래픽을 잃고 있는 곳은 health check 을 통한  load balancing 이 이루어 지고 있는 부분인데, 30초 마다 health check 을 하여3번 연속 접속실패를 할경우 서버의 이용이 불가능하다고 판단하고 트래픽을 내부에서 설정된 다른 서버로 라우팅 시킨다. 이때 보통 15대의 health checker 가 상태 체크를 하는데 2초에 한번꼴로 체킹이 이루어진다는 뜻이다. 그렇다면 약 2초*3회 / 분산서버대수 만큼의 시간동안 트래픽을 잃게 된다. 서버가 3대라면 2초의 시간동안 트래픽을 잃게되는데 적은 시간 같지만 트래픽이 증가하여 서버가 불안정할 경우 결코 적지 않은 시간 된다. health check  설정을 10초에 단위로 줄일 수도 있는데, 이 경우 1초에 1~2회 정도로 빈번히 체크를 하게 되며 30초단위로(월 0.5불) 체크하는 것에 비해 크지 않은 비용(월 1불)으로 이용할 수 있다.</p>
<p>아무튼 위의 경험을 통해서 비지니스 상황에 유연하고 신속하게 대응할 수 있는 서버구성을 구축하고자한다.</p>
<p>웹사이트의 최적화를 통해 서버의 효율을 증대시켜 서버의 가용성을 높일 수가 있기 때문에 인프라적인 대비에 앞에서 선행하고자 검토 했었는데, 이를 통해 얻게 될 서버의 가용성 범위가 물리적 증축에 비해 그리 크지 않고 비지니스의 상황이 더 나은 안정성을 요구함에 따라 인프라적인 대비를 우선 진행 하도록 하였다.</p>
<p>&nbsp;</p>
<h3>현 서버 구성,</h3>
<ul>
<li>AWS EC2 Instance(m3.medium $0.098/h) * 2  : Global distribution
<ul>
<li>www01(Production) : WP, RestAPI, MariaDB</li>
<li>dev01(Development, Production) : WP (Mirror), WP (Dev), MariaDB (Dev)</li>
</ul>
</li>
<li>Aliyun ECS Instance(ecs.n1.tiny, ecs.t1.small) * 2  : China distribution</li>
<li>AWS Route53
<ul>
<li>Geolocation based routing - GL, CN</li>
<li>Weighted routing - Load balancing</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h3>변경 후 서버 구성,</h3>
<p>중국쪽 서비스를 무기한 연기함에 따라 해당지역에 설정된 리소스를 모두 제거한다. 하나의 인스턴스 내에 구동되던 Database 및 웹 서버를 각각 저 사양의 Instance로 나누어 로드 밸런싱이 필요한 상황을 최소화 한다. Auto-scaling, ElastiCache, MySQL read replication 등의 기술을 적용하여 성능 개선 및 가용성, 탄력성 증대를 얻는다.</p>
<ul>
<li>AWS EC2 Instance(t2.small $0.04/h) *2
<ul>
<li>static01 : MariaDB (Master), RestAPI, WP</li>
<li>elastic01 : MariaDB (Read replica), WP</li>
</ul>
</li>
<li>EC2 Elastic load balancer</li>
<li>AWS ElastiCache (Cache server)</li>
<li>EC2 Auto scaling</li>
<li>AWS Route53
<ul>
<li>Weighted routing</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h3>변경 작업,</h3>
<ol>
<li>WP에 HyperDB 플러그인 설치하여 Master/Slave 의 Read/Write 설정
<ul>
<li>Master :
<ul>
<li>read hostname - master01</li>
<li>write hostname - master01</li>
</ul>
</li>
<li>Slave :
<ul>
<li>read hostname - slave01</li>
<li>write hostname - master01</li>
</ul>
</li>
</ul>
</li>
<li>Instance initialize script 작성
<ul>
<li>Pull latest source from repository</li>
<li>Get database dump and setup slave</li>
<li>Update hostname alias of hosts file
<ul>
<li>xxx.xxx.xxx.xxx master01</li>
<li>yyy.yyy.yyy.yyy slave01</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h4><strong>1. Instance Setup - static01</strong></h4>
<p>&nbsp;</p>
<p><span style="text-decoration:underline;">Launch new EC2 Instance : Ubuntu 14.04 LTS HVM</span></p>
<p>EC2 콘솔에서 인스턴스를 추가 한다. t2.micro로 생성하였는데, 추후에 실서버로 돌리때는 t2.small로 업그레이드 할 예정이다.</p>
<p>&nbsp;</p>
<p><span style="text-decoration:underline;">Install EasyEngine</span></p>
<p>Nginx + PHP(HHVM) + MariaDB + Wordpress 를 간편하게 설치해줌과 동시에 최적의 세팅을 도와주는 <a href="https://easyengine.io/" target="_blank">EasyEngine</a> 을 설치한다.</p>
<p>[code language="powershell"]<br />
# install easyengine<br />
wget -qO ee rt.cx/ee &amp;&amp; sudo bash ee<br />
[/code]</p>
<p>&nbsp;</p>
<p><span style="text-decoration:underline;">Create a site with EasyEngine</span></p>
<p>EasyEngine을 통해 웹사이트를 설치한다. 대부분의 ee 의 기본 설정값(Wordpress, DB)들은 추후에 별도로 덮어씌어지므로 변경하지 않는다.</p>
<p>[code language="powershell"]<br />
# create site on example.com with hhvm<br />
ee site create example.com --wp --hhvm<br />
[/code]</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="text-decoration:underline;">Move MySQL binary log to separate EBS volume</span></p>
<p>MySQL 로그의 증가로 인해 인스턴스의 용량이 초과되어 서비스가 중단되는 것을 막기 위해 MySQL  바이너리 로그를 별도의 EBS volume에 저장하도록 설정한다. 바이너리 로그 파일은 replication 및 복원용으로만 이용되므로 비용대비 용량이 매우 제한적인 고성능 SSD volume 에 저장해둘 필요가 없다. 대신에 비용이 저렴하여 용량제한에서 매우 자유로운 Cold HDD 를 이용한다.</p>
<p>참조:<br />
<a href="http://code.naishe.in/2012/06/mysql-with-replication-and-storage-on.html" target="_blank"> Wednesday, June 27, 2012 MySQL with Replication and storage on separate EBS Volume</a><br />
<a href="http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/ebs-detaching-volume.html" target="_blank">인스턴스에서 Amazon EBS 볼륨 분리</a></p>
<p>&nbsp;</p>
<p><span style="text-decoration:underline;">Local Memcached vs ElastiCache Memcached vs No cache comparison</span></p>
<p>&nbsp;</p>
<p>Auto-scaling 및 load balancing 을 적용하기 전에 하나의 EC2 인스턴스의 가용성 테스트를 진행하였다. 이 테스트를 통해 확인하고자 하는 것은 인스턴스 하나가 가진 성능을 최대한으로 이용할 수 있는 최적의 세팅을 찾는 것이다.  테스트는 1분 동안 가상의 트래픽을 발생시켜 트래픽량에 따른 응답시간을 측정하는 식으로 진행하였다.</p>
<p>테스트를 진행한 세팅은 다음과 같다.</p>
<ul>
<li>1 EC2 Instance with no cache</li>
<li>1 EC2 Instance with local cache (Memcached localhost)</li>
<li>1 EC2 Instance with cloud cache (Memcached on 1 ElastiCache Node)</li>
</ul>
<p>테스트를 진행한 페이지는 다음과 같다.</p>
<ul>
<li>Landing page</li>
<li>City page</li>
<li>Article page</li>
</ul>
<p>테스트를 진행한 트래픽 상황은 다음과 같다.</p>
<ul>
<li>1 user/sec</li>
<li>3 users/sec</li>
<li>5 users/sec</li>
<li>6 users/sec</li>
<li>10 ~ 100 users/sec</li>
</ul>
<p>결론을 먼저 말하자면, 캐시를 무조건 사용해야 하며 멀티서버 환경에서 캐시의 동기화를 위해 클라우드 캐시를 이용하는 것이 최적의 세팅이다.</p>
<p>캐시를 사용하지 않은 테스트에서 초당 유저수를 늘릴 수록 그에 비례하여 서버의 응답속도도 늘어났으며 6 users/sec 의 설정으로 트래픽을 발생 시켰을때 데이터베이스 서버가 다운되어 버렸다. 평균 응답 속도는  다음과 같다.</p>
<ul>
<li>1 user/sec --- 1000ms</li>
<li>3 users/sec --- 3500ms</li>
<li>5 users/sec --- 7000ms</li>
<li>6 users/sec --- time out</li>
</ul>
<p>이에 반해 캐시를 사용했을 때는 초당 2명 이상의 트래픽 환경에서는 캐시를 사용하지 않을때 보다 월등한 성능을 보였다. 최초 응답속도는 트래픽에 따라서 큰 차이 없이 느린편이었다. 이는 캐싱하는데 시간이 걸리기 때문인데, 캐시가 되고난 이후 부터는 아주 빠른 속도를 보였다. 평균 응답속도는 다음과 같다.</p>
<ul>
<li>1 user/sec --- 560ms</li>
<li>5 users/sec --- 510ms</li>
<li>20 users/sec --- 400ms</li>
<li>100 users/sec --- 1600ms</li>
<li>200 users/sec --- 3800ms</li>
</ul>
<p>눈에 띠는 점은 초당 200 명의 트래픽을 발생시켜도 서버가 죽지 않는 다는 것이다. 게다가 CloudWatch 상에 5분간의 평균  CPU Utilization 값이 최대 13% 정도로 1분간의 값을 환산 했을때 65% 정도로 안정적인 수치를 보여주었다. 캐시는 로컬호스트에 설치한 Memcached와 ElastiCache의 것을 이용하는 두가지 방법을 이용하였다. 두 세팅모두 비슷한 결과를 보여주었지만, 로컬 인스턴스의 캐시를 이용할 경우 탄력적인 멀티서버환경에서 캐시간 동기화를 세팅하기가 매우 번거롭기 때문에 클라우드 캐시를 사용하기로 결정했다.</p>
<p>참조:<br />
<a href="https://easyengine.io/tutorials/php/memcache/" target="_blank">memcache</a><br />
<a href="http://blog.celingest.com/en/2014/09/26/tutorial-update-elasticache-in-wordpress/" target="_blank">ElastiCache in WordPress</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Aliyun Ubuntu LEMP HHVM Setup</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/aliyun-ubuntu-lemp-hhvm-setup.html"/>
        <id>https://devnoff.github.io/aliyun-ubuntu-lemp-hhvm-setup.html</id>

        <updated>2019-06-13T23:13:15+09:00</updated>
            <summary>
                <![CDATA[
                    Aliyun ECS 인스턴스를 생성 후 LEMP + HHVM 을 세팅하기 까지 과정&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Aliyun ECS 인스턴스를 생성 후 LEMP + HHVM 을 세팅하기 까지 과정</p>
<h4 id="mcetoc_1dd8iuasm0">1. 사용자 추가</h4>
<p>쉘에 접속 후 root 계정을 대신해 사용할 수 있는 관리자 계정을 생성한다.</p>
<p>[code language="bash"]</p>
<p>root@iZ11ngunt9tZ:/# adduser devnoff<br> Adding user `devnoff' ...<br> Adding new group `devnoff' (1000) ...<br> Adding new user `devnoff' (1000) with group `devnoff' ...<br> Enter new UNIX password:<br> Retype new UNIX password:<br> passwd: password updated successfully<br> Changing the user information for devnoff<br> Enter the new value, or press ENTER for the default<br> Full Name []: devnoff<br> Room Number []:<br> Work Phone []:<br> Home Phone []:<br> Other []:<br> Is the information correct? [Y/n] Y</p>
<p>[/code]</p>
<p>초기화 된 우분투에서 adduser를 하였는데, locale 설정 에러가 떴다.<br> 이문제는 다음 코드로 해결</p>
<p>[code]<br> export LANGUAGE=en_US.UTF-8<br> export LANG=en_US.UTF-8<br> export LC_ALL=en_US.UTF-8<br> locale-gen en_US.UTF-8<br> dpkg-reconfigure locales<br> [/code]</p>
<h4 id="mcetoc_1dd8iuasm1">2. 추가한 사용자에게 sudo 권한 부여</h4>
<ul>
<li>/etc/sudoers 쓰기 권한 부여: # chmod u+w /etc/sudoers</li>
<li>root 계정 아래에 'devnoff ALL=(ALL:ALL) ALL' 추가</li>
<li>/etc/sudoers 권한 돌려 놓기: # chmod u-w /etc/sudoers</li>
</ul>
<h4 id="mcetoc_1dd8iuasm2">3. NginX + MariaDB + PHP 설치</h4>
<p><strong>Nginx</strong></p>
<ul>
<li>sudo apt-get update</li>
<li>sudo apt-get install nginx</li>
</ul>
<p><strong>MariaDB</strong></p>
<p>10.1 버전 설치를 위한 리포지 토리 추가</p>
<p>[code]<br> sudo apt-get install software-properties-common<br> sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xcbcb082a1bb943db<br> sudo add-apt-repository 'deb [arch=amd64,i386] http://mirrors.opencas.cn/mariadb/repo/10.1/ubuntu trusty main'<br> [/code]</p>
<p>설치</p>
<p>[code]<br> sudo apt-get update<br> sudo apt-get install mariadb-server<br> [/code]</p>
<p>시스템 시작시 실행하도록</p>
<p>[code]<br> sudo update-rc.d mysql defaults<br> [/code]</p>
<p><strong>PHP</strong></p>
<p>5.6 버전 설치 설정</p>
<p>[code]<br> sudo add-apt-repository ppa:ondrej/php5-5.6<br> [/code]</p>
<p>[code]<br> sudo apt-get update<br> [/code]</p>
<p>[code]<br> sudo apt-get install php5 php5-fpm php5-mysql<br> [/code]</p>
<p>보안을 위한 php.ini 변경</p>
<p>[code]<br> sudo nano /etc/php5/fpm/php.ini<br> [/code]</p>
<p>[code]<br> cgi.fix_pathinfo=0<br> [/code]</p>
<p>php5-fpm 재시동</p>
<p>[code]<br> sudo service php5-fpm restart<br> [/code]</p>
<p>NginX 설정</p>
<p>[code]<br> server {<br> client_max_body_size 20M;<br> listen 80;<br> server_name localhost;<br> root /home/devnoff/www;<br> index index.php;</p>
<p>location = /favicon.ico {<br> log_not_found off;<br> access_log off;<br> }</p>
<p>location = /robots.txt {<br> allow all;<br> log_not_found off;<br> access_log off;<br> }</p>
<p>location / {<br> # This is cool because no php is touched for static content.<br> # include the &amp;amp;amp;amp;quot;?$args&amp;amp;amp;amp;quot; part so non-default permalinks doesn't break when using query string<br> try_files $uri $uri/ /index.php?$args;<br> }</p>
<p>error_log /home/devnoff/travelog_wp/error.log error;</p>
<p>location ~ \.php$ {<br> fastcgi_pass unix:/var/run/php5-fpm.sock;<br> fastcgi_index index.php;<br> fastcgi_split_path_info ^(.+\.php)(.*)$;<br> fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br> include fastcgi_params;<br> fastcgi_read_timeout 600;<br> }<br> location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {<br> expires max;<br> log_not_found off;<br> }<br> }<br> [/code]</p>
<p>NginX 재시동</p>
<p>[code]<br> sudo service nginx restart<br> [/code]</p>
<p><strong>HHVM 설치</strong></p>
<p>[code]<br> wget -O - http://mirrors.noc.im/hhvm/conf/hhvm.gpg.key | sudo apt-key add -<br> echo deb http://mirrors.noc.im/hhvm/ubuntu trusty main | sudo tee /etc/apt/sources.list.d/hhvm.list<br> sudo apt-get update<br> sudo apt-get install hhvm<br> [/code]</p>
<p>NginX PHP 설정 주석 처리</p>
<p>[code]<br> # location ~ \.php$ {<br> # fastcgi_pass unix:/var/run/php5-fpm.sock;<br> # fastcgi_index index.php;<br> # fastcgi_split_path_info ^(.+\.php)(.*)$;<br> # fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;<br> # include fastcgi_params;<br> # fastcgi_read_timeout 600;<br> # }<br> [/code]</p>
<p>스크립트 실행</p>
<p>[code]<br> sudo /usr/share/hhvm/install_fastcgi.sh<br> [/code]</p>
<p>mysql 튜너<br> http://mysqltuner.com/</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>우분투 리눅스: 사용자를 그룹에 추가하기</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/ubuntu-rinugseu-sayongjareul-geurube-cugahagi.html"/>
        <id>https://devnoff.github.io/ubuntu-rinugseu-sayongjareul-geurube-cugahagi.html</id>

        <updated>2019-06-13T23:11:12+09:00</updated>
            <summary>
                <![CDATA[
                    [번역글 입니다] 어떻게 우분투 리눅스 운영체제에서 CLI를 이용하여 유저를 그룹에 추가할 수&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>[번역글 입니다]</p>
<p>어떻게 우분투 리눅스 운영체제에서 CLI를 이용하여 유저를 그룹에 추가할 수 있을까요?<br />
<span id="more-12313"></span></p>
<p>다음의 명령을 사용할 필요가 있습니다:</p>
<p>[a] <strong>useradd 명령</strong> - 새 유저를 만들거나 유저의 기본 정보를 변경하거나 새유저를 2차 그룹(secondary group)에 추가함</p>
<p>[b] <strong>usermod 명령</strong> - 시스템 계정을 수정 및 기존 사용자 계정을 변경함</p>
<h2>첫째, root 사용자로 로그인</h2>
<p>당신은 반드시 root 사용자로 로그인 해야합니다. 명령줄에서 'su -' 와 root 비밀번호를 치는  것으로 root 사용자로 전환할 수 있습니다. 그러나 우분투 리눅스 아래에서 root유저로 전활하기 위해 sudo 명령어를 사용하는 것을 추천합니다.</p>
<pre class="bash">su -</pre>
<p>OR</p>
<pre class="bash">sudo -s</pre>
<p>OR</p>
<pre class="bash">sudo useradd ...</pre>
<h2>우분투 리눅스: 새 사용자를 2차 그룹(secondary group)에 추가</h2>
<p>다음 문법을 사용하세요:</p>
<pre class="bash">useradd -G Group-name Username
passwd Username
</pre>
<p>foo 라고 불리는 그룹을 생성하고 tom 이라는 사용자를 2차그룹 foo에 추가하세요.<br />
<code>$ sudo groupadd foo<br />
$ sudo useradd -G foo tom</code><br />
또는<br />
<code># groupadd foo<br />
# useradd -G foo tom</code></p>
<p>세팅을 확인하세요:</p>
<pre class="bash">id tom
groups tom
</pre>
<p>마침내, tom 사용자를 위해 비밀번호를 설정 하세요 :<br />
<code>$ sudo passwd tom</code><br />
또는<br />
<code># passwd tom</code><br />
당신은 사용자 tom 을 복수의 그룹 - foo, bar 그리고 ftp -에 추가할 수 있습니다 :<br />
<code># useradd -G foo,bar,ftp tom</code></p>
<h2>우분투 리눅스: 새 사용자를 1차 그룹(primary group)에 추가</h2>
<p>사용자 tom을 www 그룹에 추가하기 위해 다음명령어를 사용하세요:</p>
<pre class="bash">useradd -g www tom
id tom
groups tom
</pre>
<h2>우분투 리눅스: 기존 사용자를 기존 그룹에 추가</h2>
<p>-a 옵션을 사용한 usermod 명령으로 기존 유저 jerry를 ftp(보조 및 2차) 그룹에 추가하기 -즉, 유저를 보조 그룹(들)에 추가하기. 오직 -G 옵션을 사용하세요.</p>
<pre class="bash">usermod -a -G ftp jerry
id jerry
</pre>
<p>기존 사용자 jerry의 1차 그룹(primary group)을 www 그룹으로 변경 (-g 옵션을 쓰세요):</p>
<pre class="bash">usermod <strong>-g</strong> www jerry
</pre>
<p>&nbsp;</p>
<p>원문: http://www.cyberciti.biz/faq/ubuntu-add-user-to-group/</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>hosts</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/hosts.html"/>
        <id>https://devnoff.github.io/hosts.html</id>

        <updated>2019-06-13T23:11:12+09:00</updated>
            <summary>
                <![CDATA[
                    실제 운영중인 서비스에 웹서버와 데이터베이스 서버가 원격으로 연결되어 있고 개발은 클론으로 로컬에&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>실제 운영중인 서비스에 웹서버와 데이터베이스 서버가 원격으로 연결되어 있고 개발은 클론으로 로컬에 두 서버를 구현해서 한다면, 실 서버에 변경사항을 반영할때 설정파일의 hostname 을 무시하고 반영하거나 매번 이름을 변경해주어야 한다.</p>
<p>좀 더 쉽게 얘기를 하면 웹서버와 데이터베이스가 같은 호스트내에 있다면 호스트네이임은 보통 localhost 또는 127.0.0.1 일 것이고, db 접속 설정의 hostname에 이를 사용하는데, 만약 다를 경우 db의 hostname 은 234.231.xxx.xxx 등으로 달리 설정되므로 설정파일의 변경사항을 반영할때 주의를 해야한다.</p>
<p>이 설정을 조금 더 안전하게 하기 위해 hosts 파일에서 hostname 의 별칭을 지정하여 사용할 수 있다. Unix/Linux 계열의 시스템에서 파일의 경로는 /etc/hosts 이다.</p>
<p>설정 예시</p>
<blockquote><p>127.0.0.1                  localhost db01</p>
<p>127.0.0.1                  nickname2</p>
<p>234.240.xxx.xxx    db02</p></blockquote>
<p>127.0.0.1 의 IP 주소에 대해서 localhost, db01, nickname2 라는 별칭을 지정하였다.</p>
<p>234.240.xxx.xxx 의 원격 IP주소에 대해서는 db02 라는 별칭을 지정하였다.</p>
<p>&nbsp;</p>
<p>아래는 Codeigniter 로 구현된 웹서버의 db 설정이다</p>
<blockquote><p>$db['default']['hostname'] = 'db01';<br />
$db['default']['username'] = 'root';<br />
$db['default']['password'] = 'root';</p>
<p>$db['eanprod']['hostname'] = 'db02';<br />
$db['eanprod']['username'] = 'user';<br />
$db['eanprod']['password'] = 'password';</p></blockquote>
<p>이렇게 함으로써 로컬 개발 서버에서 작업하던 것을 실서버로 반영할때 설정파일을 무시한다거나 매번 변경하는 작업을 피할 수 있다.</p>
<p>&nbsp;</p>
<p>참조: <a href="http://en.wikipedia.org/wiki/Hosts_(file)">http://en.wikipedia.org/wiki/Hosts_(file)</a></p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Usage Analysis 3 Days</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/usage-analysis-3-days.html"/>
        <id>https://devnoff.github.io/usage-analysis-3-days.html</id>

        <updated>2019-06-13T23:11:12+09:00</updated>
            <summary>
                <![CDATA[
                    3일 동안 앱업데이트 후 지난 한달간의 앱 이용형태를 추적한 데이터를 바탕으로 이용&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>3일 동안 앱업데이트 후 지난 한달간의 앱 이용형태를 추적한 데이터를 바탕으로 이용 형태에 대한 분석을 진행하였다.</p>
<p>첫날.</p>
<p>Flurry 에서 4일치의 Event log 를 긁어 와서, 이벤트가 가장 많이 발생한 30명의 Top User를 추출하였다. 이를 바탕으로 앱을 많이 이용하는 사용자는 이용 성향이 뚜렷하게 구분되는 편인데, 디스커버에서 시간을 보내거나 자신들의 컨텐츠만을 보거나 작성하는 행태를 보였다. 디스커버에서 시간을 보낸 Top User 중 절반은 자신의 컨텐츠가 거의 없었고 , 최근 1달 이내 가입한 이용자였다.</p>
<p>둘째날.</p>
<p>Flurry 에서 한달치 Event Log를 긇어왔다. Flurry에서 이를 한번에 받을 수 있는 방법을 제공하지 않아서, 반자동으로 작동하는 코드를 짜서 약 두시간 가량 받았다. 전체 1만번 정도의 세션이 만들어졌으며, 약 1천명 정도의 사용자가 앱을 실행하였다. 다시 말해 지난 한달간 천여명의 상용자가 한명 당 열번 정도 앱을 실행하였는데, 이 중 30%는 그 기간동안 가입한 이용자이다.</p>
<p>셋째날.</p>
<p>데이터를 입체적으로 분석하기 위해서, 각 화면 및 이벤트마다  네 가지 사용성(Discover, Search, Write, Lookback)에 대한 점수를 매겼다. 그리고 사용자 별로 네 가지 사용성에 대한 성향을 수치화 시켰다. 이를 다시 이용량 순으로 정렬하여 지난 한달 간 이용자의 이용 행태를 한 눈에 볼 수 있는 자료로 만들었다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Flurry Event Log -&gt; Usage Trend</p>
<p>1. 사용자별 전체 이벤트 발생 횟수를 합한 결과값 순으로 사용자의 각 이벤트의 합계.</p>
<p>2. 이벤트별 사용성 점수에 따른 사용성 요약</p>
<p>3. 이벤트가 많이 발생한 순으로 사용자 컨텐츠 통계와 사용성 요약 보기</p>
<p>&nbsp;</p>
<p>Flurry Event Log -&gt; Using Pattern</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Facebook Graph API Day 1</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/facebook-graph-api-day-1.html"/>
        <id>https://devnoff.github.io/facebook-graph-api-day-1.html</id>

        <updated>2019-06-13T23:11:12+09:00</updated>
            <summary>
                <![CDATA[
                    Spotsetter 라는 앱이 페이스북 컨텐츠를 가져와서 서비스에 이용하는 방식에 대해 분석한다. 페이스북을 통해&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Spotsetter 라는 앱이 페이스북 컨텐츠를 가져와서 서비스에 이용하는 방식에 대해 분석한다. 페이스북을 통해 트래블로그에 가입한 유저에 대해서 아래의 조건에 대한 컨텐츠를 가져오는 방법을 알아보았다.</p>
<ol>
<li>유저가 페이스북에서 작성한 게시글 중 플레이스 정보가 있는 것 가져오기</li>
<li>유저가 페이스북에서 체크인하거나 유저의 친구의 채크인(또는 상태)에 태그가 된 것 가져오기</li>
<li>유저의 페이스북 친구들이 체크인 하거나 그들의 친구들의 체크인(또는 상태)에 태그가 된 것 가져오기</li>
<li>특정 Region 에 속한 게시글(본인 및 친구가 작성하거나 태그된) 가져오기</li>
<li>특정 Place의 게시글(본인 및 친구가 작성하거나 태그된) 가져오기</li>
<li>유저가 like한 컨텐츠 가져오기(유저 성향 분석)</li>
</ol>
<p>조건에 따라 FQL(Facebook Query Language) 과 Graph API 중 쿼리하기 용이한 것을 이용하였다.</p>
<p><strong>1. 유저가 페이스북에서 작성한 게시글 중 플레이스 정보가 있는 것 가져오기</strong></p>
<p>이에 대한 쿼리문을 작성하면서 테이블 컬럼의 네이밍만으로 각 테이블간 관계를 파악하기가 조금 어려웠다. 엔티티들의 특성을 고려하여 관계를 추정하여 아래의 쿼리를 통해 위의 조건에 해당하는 결과를 얻을 수 있었다.</p>
<p>{"status":"select place_id, status_id, message from status where status_id IN (select id from location_post where author_uid = me())","checkin":"select target_id, message from checkin where checkin_id IN (select id from location_post where author_uid = me())"}</p>
<p><span style="text-decoration:underline;">Descriptions</span></p>
<ul>
<li>location_post.id : ID of the object associated with this location</li>
<li>status.status_id : The ID of the status message</li>
<li>checkin.checkin_id : The ID of the check-in.</li>
<li>checkin.target_id : The ID of Event or Page the user is checking into.</li>
<li>place.page_id : The Facebook Page ID of the place</li>
</ul>
<p>location_post 테이블의 id  는 위치정보가 있는 object 를 가리키고, checkin 테이블의 target_id 는 place테이블의 page_id를 가르킨다.</p>
<p><strong>2. 유저가 페이스북에서 체크인하거나 유저의 친구의 채크인(또는 상태)에 태그가 된 것 가져오기</strong></p>
<p>Graph API - "user_id/checkins"</p>
<p><strong>3. 유저의 페이스북 친구들이 체크인 하거나 그들의 친구들의 체크인(또는 상태)에 태그가 된 것 가져오기</strong></p>
<p>Graph API - "user_id?fields=friends.offset(0).limit(20).fields(checkins.fields(coordinates,place,from),name,picture)"</p>
<p><strong>4. 특정 Region 에 속한 게시글(본인 및 친구가 작성하거나 태그된) 가져오기</strong></p>
<p>Graph API 로는 좌표를 이용한 특정 Region 에 대한 위의 쿼리는 불가능 하다. FQL 을 이용하면 쿼리가 가능하긴 하나 'join' 문을 사용할 수 없어서 한번에 데이터를 가져오는데 한계가 있다. 이 시점에 Spotsetter 가 어떻게 서비스를 구현해냈는지 추측할 수 있는데, 최초 페이스북과 연동 후 위의 2,3번 Graph API 를 이용해 사용자 데이터를 모두 가져와 캐싱을하여 자체 DB에서 쿼리를 한 것 일것이다. 캐싱없이 실시간으로 API 를 호출해서 데이터를 만들어 낼 수는 있지만, 원하는 형태의 데이터를 만들기 위해서 매우 비효율적인 과정을 거쳐야 하기때문에 이를 이용하지 않았을 것이며, 앱의 반응속도로 보아 캐싱을 한 것이 틀림 없어 보인다.</p>
<p><strong>5. 특정 Place의 게시글(본인 및 친구가 작성하거나 태그된) 가져오기</strong></p>
<p>4와 마찬가지로 구현</p>
<p><strong>6. 유저가 like한 컨텐츠 가져오기(유저 성향 분석)</strong></p>
<p>Graph API - "user_id/likes"</p>
<p>유저가 like한 페이지 목록을 가져온다</p>
<p>[code language="javascript" gutter="false" autolinks="false"]</p>
<p>{<br />
	&quot;data&quot;: [<br />
		{<br />
			&quot;category&quot;: &quot;Tv show&quot;,<br />
			&quot;name&quot;: &quot;쇼미더머니 2&quot;,<br />
			&quot;created_time&quot;: &quot;2013-07-05T14:37:32+0000&quot;,<br />
			&quot;id&quot;: &quot;138621366340709&quot;<br />
		},<br />
		{<br />
			&quot;category&quot;: &quot;Company&quot;,<br />
			&quot;name&quot;: &quot;Lomography Embassy Store Seoul&quot;,<br />
			&quot;created_time&quot;: &quot;2013-06-15T08:59:30+0000&quot;,<br />
			&quot;id&quot;: &quot;180737175415514&quot;<br />
		}<br />
	],<br />
		&quot;paging&quot;: {<br />
		&quot;next&quot;: &quot;https://graph.facebook.com/xxxxxxx/likes?limit=2&amp;offset=2&amp;__after_id=180737175415514&quot;<br />
	}<br />
}</p>
<p>[/code]</p>
<p>References</p>
<ul>
<li><a href="https://developers.facebook.com/docs/reference/api/" target="_blank">Facebook Graph API</a></li>
<li><a href="https://developers.facebook.com/docs/reference/fql/" target="_blank">Facebook FQL</a></li>
<li><a href="https://developers.facebook.com/tools/explorer" target="_blank">Graph API Explorer</a></li>
</ul>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Bug Fixing, Deals Hong Kong Integration, Tracking User&#x27;s Behaviors</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/bug-fixing-deals-hong-kong-integration-tracking-users-behaviors.html"/>
        <id>https://devnoff.github.io/bug-fixing-deals-hong-kong-integration-tracking-users-behaviors.html</id>

        <updated>2019-06-13T23:11:12+09:00</updated>
            <summary>
                <![CDATA[
                    Tracking User's Behaviors 비지니스 파트에서 다음 버전의 프로덕트에 대한 기획을 담당하면서, 설계과정에&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><strong>Tracking User's Behaviors</strong></p>
<p>비지니스 파트에서 다음 버전의 프로덕트에 대한 기획을 담당하면서, 설계과정에 필요한 자료를 요청해왔다. 앱 내에서 사용자가 이동하는 경로 및 발생하는 이벤트 그리고 페이지 내에서 머문 시간 등을 사용자의 종류(지역, 언어, 가입경로 등)에 따라 한 눈에 볼 수 있는 자료와 모든 사용자의 액션을 추적해달라고 하는게 요지였다. Flurry  데이터와 트래블로그 API 요청을 기록한 데이터를 종합하여 당장에 원하는 자료는 만들 수 있지만, 모든 액션 및 경로를 추척해달라는 요청에 대해서는 그 영역이매우 광범위하고, 모호하여 바로 진행할 수 없다는 입장을 전달했다.</p>
<p>이에 대해 팀원들간에 논쟁이 있었는데, 개발팀에서 데이터 분석을 전담해야하는 것이 아니냐하는 의견과, '모든'이라는 말은 불명확하기 때문에 분석이 필요한 영역에 대한 확실한 정의와 왜 그것을 해야하는지 알려주면 분석 자료를 만들어 주겠다는 의견, 그리고 다 함께 분석작업에 대해서 논의 한 뒤 결정하자는 의견이 대립되었다. 결과적으로 프로덕트 설계를 맡은 비지니스팀에서 분석이 필요한 영역과 자료에 대한 정의를 한 뒤 개발팀에게 가이드라인을 넘겨주는걸로 일단락 되었다.</p>
<p><strong>Bug Fixing</strong></p>
<p>페이스북 연결에 문제가 있다는 리포팅이 있었다. 확인 결과 페이스북 세팅을 유지하는 피처를 적용하면서, 페이스북 object 에 settings라는 프로퍼티를 추가하였는데, 이 프로퍼티가 존재하지 않는 이전버전에서 크래시되는게 원인이었다. not exist property exception 을 대부분의 object에 적용하였는데, 최근에 작업한 object에 그게 빠져있어서 이를 보완하는 코드를 삽입했다.</p>
<p><strong>Deals Hong Kong Integration</strong></p>
<p>파트너 업체의 deal을 앱에서 표시해주는 방안에 대해서 논의 했다. API 는 xml 형태로 보내어 질 것이고, 이 데이터를 이용해 앱에서 모바일 마크업을 이용해 보여 준 뒤 유저의 액션에 따라 사파리로 리다이렉트 시키는 방식으로 구현이 하는 것으로 결정 됐다.</p>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Push Notification Day 2</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/push-notification-day-2.html"/>
        <id>https://devnoff.github.io/push-notification-day-2.html</id>

        <updated>2019-06-13T23:11:12+09:00</updated>
            <summary>
                <![CDATA[
                    Done푸시알림 및 뉴스 항목 추가Somebody liked the same log that I likedMy&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Done</p>
<ul>
<li>푸시알림 및 뉴스 항목 추가
<ul>
<li>Somebody liked the same log that I liked</li>
<li>My Contents was selected featured Log/Book</li>
</ul>
</li>
<li>앱 업데이트 submit</li>
</ul>

            ]]>
        </content>
    </entry>
    <entry>
        <title>Push Notification Day 1 and Learning User&#x27;s interest</title>
        <author>
            <name>devnoff</name>
        </author>
        <link href="https://devnoff.github.io/push-notification-day-1-and-learning-users-interest.html"/>
        <id>https://devnoff.github.io/push-notification-day-1-and-learning-users-interest.html</id>

        <updated>2019-06-13T23:11:12+09:00</updated>
            <summary>
                <![CDATA[
                    To do &nbsp; 앱에서 발생하는 사용자의 액션에 대해서 푸시 및 앱내 알림을&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>To do</p>
<ul>
<li>푸시 노티피케이션 적용방안에 대한 협의</li>
<li>API 적용방안에 대한 협의</li>
</ul>
<p>&nbsp;</p>
<p>앱에서 발생하는 사용자의 액션에 대해서 푸시 및 앱내 알림을 강화하기로 결정되어 이에 대한 작업을 진행한다.</p>
<ul>
<li>My Facebook/Weibo Friends Signup</li>
<li>My Facebook/Weibo Friends Update contents (at the 1st time, not everytime)</li>
<li>Somebody liked the same log that I liked</li>
<li>My Contents was selected featured Log/Book</li>
<li>You are pioneer of this city</li>
<li>You are Mayor of this city</li>
<li>Notice : New Travelers(Power Blogger) joined or We are now serve new airline service , ... Customized Featured Contents Update Alert (After curation part done)</li>
</ul>
<p>위의 항목에 대해 알림을 추가할 것이며, 앞으로 알림이 더 추가될 것을 감안하여 설계를 하도록 한다.</p>
<p>&nbsp;</p>
<p>앱내에서 사용자의 이용형태를 추적하여 사용자의 성향을 분석하는 방법에 대한 논의가 있었다. 기술적으로 사용자의 액션 및 경로를 추적하기 위헤 데이터를 쌓는 것은 가능 하지만, 이를 해석하고 우리에게 의미있는 자료로 쓰는 것에 대한 배경지식이 없기 때문에 이에 대한 연구를 진행하거나, 외부 인력을 동원하자는 의견이 있었다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

            ]]>
        </content>
    </entry>
</feed>
